<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <meta name="language" content="en">
    <link rel="canonical" href="https://datamb.football/plotteam/" />
<link rel="alternate" hreflang="x-default" href="https://datamb.football/plotteam"/>
<link rel="alternate" hreflang="en" href="https://datamb.football/plotteam/?lang=en" />
    <link rel="shortcut icon" type="image/x-icon" href="https://datamb.football/favicon.ico">
    <meta name="description" data-i18n="meta.description" content="Plot Top 7 League team statistics. Visualize team performance and analyze multiple metrics such as Goals, Goals conceded, xG, Shots on target, Pressing, Defensive duels, Pass completion and more for teams in Premier League, La Liga, Bundesliga, Serie A, Ligue 1, Eredivisie, Primeira Liga.">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@DataMB_">
    <meta name="twitter:title" content="DataMB | Plot Teams">
    <meta name="twitter:description" content="Generate scatter plots for Top 7 League teams">
    <meta name="twitter:image" content="https://datamb.football/vignettes/teamplots.png">
    <meta property="og:image" content="https://datamb.football/vignettes/teamplots.png">
    <title data-i18n="meta.title">DataMB | Plot Teams</title>
    <script>
        (function() {
            var width = window.innerWidth;
            var viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
      if (width < 645) {
                
            var initialScale = width / 645;
      viewportMeta.setAttribute('content', 'width=device-width, initial-scale=' + initialScale + ', user-scalable=no');
      } else {
                  var fixedScale = 1;
          viewportMeta.setAttribute('content', 'width=device-width, initial-scale=' + fixedScale + ', user-scalable=no');
      
        }
          } 
      })();
      </script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <link rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f5f7fa;
            --container-bg: #ffffff;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --hover-color: #f0f0f0;
            --button-color: #3498db;
            --button-text: #ffffff;
            --header-bg: #ffffff;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .dark-mode {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #0e0f0f;
            --container-bg: #1a1a1a;
            --text-color: #e0e0e0;
            --border-color: #333333;
            --hover-color: #252525;
            --button-color: #2980b9;
            --button-text: #ffffff;
            --header-bg: #0e0f0f;
            --shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        .header {
            background-color: var(--header-bg);
            display: flex;
            padding: 20px;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow);
            position: relative;
            font-family: system-ui;
            top: 0;
            z-index: 100;
        }


        .container {
            max-width: 1200px;
            margin: 30px auto;
            padding: 0 20px;
            box-sizing: border-box;
        }

        /* Replace plot-container with a simpler structure */
        .chart-wrapper {
            background-color: var(--container-bg);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            width: 100%;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
            width: 100%;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
        }

        select, input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--container-bg);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: border-color 0.2s;
            height: 36px;
            box-sizing: border-box;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Ensure consistent height for controls in the same row */
        select, input, .btn:not(.btn-icon), .custom-select-trigger, .metric-select-trigger {
            height: 36px;
            box-sizing: border-box;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: var(--button-color);
            color: var(--button-text);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            height: 36px;
            box-sizing: border-box;
        }

        .btn:hover {
            background-color: #2980b9;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .btn-outline:hover {
            background-color: var(--hover-color);
        }

        .btn-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 6px;
        }

        #search-bar, #select-league {
            width: 178px;
        }

        #select-x, #select-y {
            width: 190px;
        }

        /* Add tooltip for icon buttons */
        .btn-icon .icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .btn-icon i {
            font-size: 18px;
        }
        .chart-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            margin-top: 30px; /* Consistent spacing from controls */
        }

        #scatter-plot {
            width: 100%;
            height: auto; /* Height will be set dynamically */
            display: block;
            margin: 0 auto;
            max-width: 1082px;
        }
        
  

        .tooltip {
            position: absolute;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: var(--shadow);
            z-index: 1000;
        }

        /* Custom button tooltips */
        .btn-tooltip {
            position: relative;
            display: inline-block;
        }

        .btn-tooltip .btn-tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: var(--container-bg);
            color: var(--text-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            font-weight: normal;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            pointer-events: none;
        }

        /* Hide button tooltips on mobile */
        @media (max-width: 768px) {
            .btn-tooltip .btn-tooltip-text {
                display: none;
            }
        }

        .btn-tooltip .btn-tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--border-color) transparent transparent transparent;
        }

        .btn-tooltip:hover .btn-tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .player-name {
            font-size: 12px;
            font-weight: 500;
        }

        circle {
            cursor: pointer;
            transition: r 0.2s, fill 0.2s;
        }


        /* Add new styles for better search highlighting */
        circle.search-match {
            fill: #ff3366 !important; /* Bright pink fill */
            stroke: #ffffff;
            stroke-width: 2px;
            filter: drop-shadow(0 0 5px rgba(255, 51, 102, 0.7));
            animation: circlePulse 1.5s infinite ease-in-out;
        }

        .dark-mode circle.search-match {
            stroke: #000000;
        }

        @keyframes circlePulse {
            0% { r: 6; }
            50% { r: 9; }
            100% { r: 6; }
        }

        .team-label.search-match {
            font-weight: 700 !important;
            fill: #ff3366 !important;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 1));
            opacity: 1 !important;
            animation: labelPulse 1.5s infinite ease-in-out;
        }

        @keyframes labelPulse {
            0% { font-size: 12px; }
            50% { font-size: 14px; }
            100% { font-size: 12px; }
        }

        .dark-mode .team-label.search-match {
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 1));
        }

        .team-label.search-dimmed {
            opacity: 0 !important;
        }

        .team-label {
            pointer-events: none;
            text-shadow: 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white, 0px 0px 2px white;
        }

        .dark-mode .team-label {
            fill: #f5f5f5 !important;
            text-shadow: 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a, 0px 0px 2px #1a1a1a;
        }

        .dark-mode-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--container-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
            z-index: 100;
            transition: background-color 0.3s;
        }

        .dark-mode-toggle.mobile-only {
            position: fixed;
            bottom: 20px;
            right: 20px;
        }

        .dark-mode-toggle.pc-only {
            position: relative;
            bottom: auto;
            right: auto;
        }

        .pc-only {
            display: flex;
        }

        .mobile-only {
            display: none;
        }

        .toggle-icon::before {
            font-family: "Ionicons";
            content: "\f467";
            font-size: 30px;
            color: var(--text-color);
        }

        .dark-mode .toggle-icon::before {
            content: "\f3b0";
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .pc-only {
                display: none;
            }
            
            .mobile-only {
                display: flex;
            }
  
            
  .chart-wrapper {
      padding: 15px;
  }
  
  
  /* Remove fixed height for scatter plot - now handled by updateChartDimensions */
  #scatter-plot {
      min-height: 500px; /* Minimum height for mobile */
  }
  
  select, input {
      width: 100%;
  }
  
  
  /* Make text elements more readable on mobile */
  .x-label, .y-label {
      font-size: 12px;
  }
  
  /* Adjust tooltip position for mobile */
  .tooltip {
      max-width: 80%;
  }
}

        /* Styles for the diagonal reference line */
        .dark-mode .xy-line {
            stroke: #3cb371; /* Slightly different green for dark mode */
        }


  
  .search-input-modal {
      display: none;
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7); 
      z-index: 999; 
  }
  
  .search-input-container {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #fff;
      padding: 20px;
      border-radius: 4px;
      z-index: 1000; 
  }
  
  #searchInput {
              width: 370px;
              padding: 12px;
              border: 3px solid #ccc;
              border-radius: 4px;
              font-size: 18.3px;
              outline: none;
              height: 50px;
              color: #000000;
              background-color: #fff;
              ;          }
  
          #autocompleteBox {
              width: 370px;
              max-height: 150px;
              overflow-y: auto;
              background-color: #fff;
          }
  
  
          #autocompleteBox ul {
              list-style: none;
              padding: 0;
              margin: 0;
          }
  
          #autocompleteBox li {
              margin: 0;
              padding: 5px;
          }
  
          #autocompleteBox {
              line-height: 2; 
              text-align: center !important;
  
          }
  
          #autocompleteBox a {
              text-decoration: none;
              font-family: Arial, sans-serif;
              text-align: center !important;
              color: #333 !important;
              cursor: pointer; 
          }
  
          #autocompleteBox li:hover {
              background-color: #f0f0f0;
          }
          #searchButton3 {
            padding: 8.5px;  /* Reduced from 10px */
  background-color: #0074d9;
  color: #fff;
  border: none;
  width: 34px;  /* Reduced from 40px */
  height: 34px;  /* Reduced from 40px */
  border-radius: 50%;
  cursor: pointer;
  font-size: 17px;  /* Reduced from 20px */
  }


  body.dark-mode .header .button10 {
      color: #aeaeae;
}
body.dark-mode .header .button10:hover {
  color: #2563eb;
background-color: #ffffff;
}

    body.dark-mode header a {
      color: #aeaeae;
}

body.dark-mode .header .logo img {
  opacity: 0.88;
}


body.dark-mode .language-button {
      background-color: #0F0F0E;
      color: #aeaeae;
}

body.dark-mode .language-button:hover {
      background-color: #0F0F0E;
      color: #aeaeae;
}



  

.header .logo {
  display: flex;
  align-items: center;
  margin-right: auto; /* Push logo to the left */
}

.header .logo img {
  height: 34px;
  width: auto;
  opacity: 0.84;
}
.header .logo-text {
  margin-left: 10px;
  font-size: 23px;
  font-weight: 600;
  transform: translateY(-1.1px); /* Move logo text slightly higher */
}

.header .navigation {
  display: flex;
  align-items: center;
  gap: 25px; /* Reduced gap between buttons */
  position: absolute;
  left: 50%;
  transform: translateX(-50%) translateY(-2px); /* Center the navigation and move it higher */
}



.header .button10 {
  padding: 0.5rem 1rem;
  text-decoration: none;
  color: #333;
  line-height: 1.6;
  border-radius: 4px;
  transition: background-color 0.2s;
  font-size: 1.1rem;  /* Added larger font size */
}


.header .button10:hover {
  background-color: #f0f0f0;
  color: #2563eb;

}



/* Group search and language buttons */
.header-right {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto; /* Push buttons to the right */
  transform: translateY(-1.25px); /* Move search and language buttons higher */
}

header a {
      color: black;
      text-decoration: none;
    }

    .language-switcher-container {
  position: relative;
  display: none;
}

.language-button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 10px;
  color: #444444;
  display: flex;
  align-items: center;
  font-size: 17px;
}

.language-button iconify-icon {
  font-size: 24px;
  opacity: 0.7;
}

.language-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  padding: 10px;
  width: 200px;
  z-index: 1000;
}

.language-option {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  color: #444444;
  text-decoration: none;
}



.language-option iconify-icon {
  margin-right: 10px;
  font-size: 20px;
}

.language-dropdown.show {
  display: block;
}

/* Styles for flag icons in select dropdown */
#select-league option {
    display: flex;
    align-items: center;
    padding: 8px 12px;
}

#select-league iconify-icon {
    display: inline-flex;
    vertical-align: middle;
}

/* Styles for custom league selector dropdown */
.custom-select-container {
    position: relative;
    width: 172px;
}

.metric-select-container {
    position: relative;
    width: 192px;
}

.custom-select-trigger, .metric-select-trigger {
    display: flex;
    align-items: center;
    padding: 0 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background-color: var(--container-bg);
    color: var(--text-color);
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    cursor: pointer;
    user-select: none;
    position: relative;
    line-height: 1;
}

.custom-select-trigger span, .metric-select-trigger span {
    display: inline-block;
    transform: translateY(1px);
    white-space: nowrap;
    overflow: hidden;
    max-width: calc(100% - 20px); /* Account for the icon width and margin */
    line-height: normal; /* Ensure consistent line height */    
}

.custom-select-trigger::after, .metric-select-trigger::after {
    content: '';
    width: 6px;
    height: 6px;
    margin-left: auto;
    border-right: 1.5px solid var(--text-color);
    border-bottom: 1.5px solid var(--text-color);
    transform: rotate(45deg) translateY(-2px);
    transition: transform 0.3s;
    opacity: 0.7;
    margin-right: 2px;
}

.custom-select-trigger.open::after, .metric-select-trigger.open::after {
    transform: rotate(-135deg) translateY(1px);
}

.custom-select-options, .metric-select-options {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: var(--container-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    margin-top: 5px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 100;
    font-size: 13px;
    display: none;
    box-shadow: var(--shadow);
}

.custom-select-option, .metric-select-option {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    cursor: pointer;
}

.custom-select-option:hover, .metric-select-option:hover {
    background-color: var(--hover-color);
}

.custom-select-option.selected, .metric-select-option.selected {
    background-color: rgba(52, 152, 219, 0.1);
}

.custom-select-option iconify-icon, .metric-select-option iconify-icon {
    margin-right: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

body.dark-mode .language-button:hover {
      background-color: #0F0F0E;
      color: #aeaeae;
}

body.dark-mode .language-dropdown {
  background: #e8e6e6;
}

body.dark-mode .language-option {
  color: #000000;
}

/* Dark mode styles for custom dropdown */
.dark-mode .custom-select-trigger,
.dark-mode .custom-select-options,
.dark-mode .metric-select-trigger,
.dark-mode .metric-select-options {
    border-color: var(--border-color);
    background-color: var(--container-bg);
    color: var(--text-color);
}

.dark-mode .custom-select-option:hover,
.dark-mode .metric-select-option:hover {
    background-color: var(--hover-color);
}

.dark-mode .custom-select-option.selected,
.dark-mode .metric-select-option.selected {
    background-color: rgba(52, 152, 219, 0.2);
}

.custom-select-option iconify-icon, .metric-select-option iconify-icon {
    margin-right: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* Adjust flag icon alignment in the trigger */
#league-select-trigger iconify-icon {
    margin-right: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transform: translateY(-1px);
}
@media screen and (max-width: 550px) { .header .navigation { display: none; } }

        /* Enhanced Dark Mode Styles */
        .dark-mode .chart-wrapper {
            background-color: var(--container-bg);
            border: 1px solid #333;
        }

        .dark-mode .btn {
            background-color: var(--button-color);
        }

        .dark-mode .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        .dark-mode .btn-outline:hover {
            background-color: var(--hover-color);
            border-color: #444;
        }


        .dark-mode input, 
        .dark-mode select {
            background-color: #1a1a1a;
            color: var(--text-color);
            border-color: #333;
        }

        .dark-mode input::placeholder {
            color: #777;
        }

        .dark-mode input:focus, 
        .dark-mode select:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .dark-mode .tooltip {
            background-color: #1a1a1a;
            border-color: #333;
            color: var(--text-color);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .dark-mode .legend {
            border-top-color: #333;
        }

        .dark-mode .legend-item {
            color: #ccc;
        }

        .dark-mode .btn-tooltip .btn-tooltip-text {
            background-color: #1a1a1a;
            border-color: #333;
            color: #e0e0e0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .dark-mode .btn-tooltip .btn-tooltip-text::after {
            border-color: #333 transparent transparent transparent;
        }

        .dark-mode .team-label {
            fill: #e0e0e0 !important;
            text-shadow: 0px 0px 3px #0e0f0f, 0px 0px 3px #0e0f0f, 0px 0px 3px #0e0f0f, 0px 0px 3px #0e0f0f;
        }

        .dark-mode .x-axis path,
        .dark-mode .y-axis path,
        .dark-mode .x-axis line,
        .dark-mode .y-axis line {
            stroke: #444;
        }

        .dark-mode .x-axis text,
        .dark-mode .y-axis text {
            fill: #aaa;
        }

        .dark-mode .x-label,
        .dark-mode .y-label {
            fill: #ccc;
        }

        .dark-mode .median-line {
            stroke: rgba(255, 255, 255, 0.2) !important;
        }

        .dark-mode .xy-line {
            stroke: #2ecc71;
            opacity: 0.8;
        }

        .dark-mode .dark-mode-toggle {
            background-color: #1a1a1a;
            border: 1px solid #333;
        }

        .dark-mode .toggle-icon::before {
            color: #e0e0e0;
        }

 



        .dark-mode #searchButton3 {
            background-color: #0074d9;
            color: #fff;
        }


        .dark-mode .header .button10 {
            color: #aaa;
        }

        .dark-mode .header .button10:hover {
            color: #2563eb;
            background-color: #1a1a1a;
        }

        .dark-mode header a {
            color: #aaa;
        }

        .dark-mode .header .logo img {
            opacity: 0.9;
            filter: brightness(0.9);
        }

        .dark-mode .language-button {
            background-color: #0e0f0f;
            color: #aaa;
        }

        .dark-mode .language-button:hover {
            background-color: #1a1a1a;
        }

        .dark-mode .language-dropdown {
            background: #1a1a1a;
            border: 1px solid #333;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .dark-mode .language-option {
            color: #e0e0e0;
        }

        .dark-mode .language-option:hover {
            background-color: #252525;
        }

        .dark-mode #search-bar::placeholder {
            color: #777;
        }

        .dark-mode circle {
            stroke-width: 1px;
        }

        .dark-mode circle.search-match {
            fill: #ff3366 !important;
            stroke: #0e0f0f;
            stroke-width: 2px;
            filter: drop-shadow(0 0 5px rgba(255, 51, 102, 0.7));
        }

  
        
        /* Additional dark mode styles for chart elements */
        .dark-mode .chart-container {
            background-color: var(--container-bg);
        }
        
  
        
    
        
        .dark-mode .team-label.search-match {
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 1));
        }
        
        /* Fix for custom select dropdown in dark mode */
        .dark-mode .custom-select-trigger::after, 
        .dark-mode .metric-select-trigger::after {
            border-right: 1.5px solid var(--text-color);
            border-bottom: 1.5px solid var(--text-color);
        }
        
        /* Improve contrast for selected items in dark mode */
        .dark-mode .custom-select-option.selected, 
        .dark-mode .metric-select-option.selected {
            background-color: rgba(52, 152, 219, 0.3);
        }
        
        /* Improve visibility of SVG elements in dark mode */
        .dark-mode svg text {
            fill: #ccc;
        }
        
        .dark-mode .legend-color {
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Improve button states in dark mode */
        .dark-mode .btn:hover {
            background-color: #3498db;
        }
        
        .dark-mode .btn-outline:active {
            background-color: #333;
        }
        
        /* Improve focus states for accessibility */
        .dark-mode input:focus,
        .dark-mode select:focus,
        .dark-mode .btn:focus {
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.5);
        }
        
        /* Fix for buttons staying focused with blue outline */
        button:focus, 
        .btn:focus, 
        select:focus, 
        input:focus {
            outline: none;
        }
        
        /* Custom focus styles for better accessibility */
        button:focus-visible, 
        .btn:focus-visible, 
        select:focus-visible, 
        input:focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-color);
        }
        
        /* Remove focus styles when using mouse */
        button:focus:not(:focus-visible), 
        .btn:focus:not(:focus-visible), 
        select:focus:not(:focus-visible), 
        input:focus:not(:focus-visible) {
            box-shadow: none;
        }



.logo img {
  width: 50px;
  height: 50px;
}

/* Promo links styling */
.promo-links-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    margin: 15px auto 25px;
    max-width: 800px;
    flex-wrap: wrap;
    padding: 0 20px;
}

.promo-link {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    background-color: var(--container-bg);
    color: var(--text-color);
    text-decoration: none;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.3s ease;
    box-shadow: var(--shadow);
    font-weight: 500;
    flex: 1;
    min-width: 220px;
    max-width: 350px;
    justify-content: center;
}

.promo-link iconify-icon {
    margin-right: 8px;
}

.promo-link:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.radar-link {
    border-left: 4px solid #3498db;
}

.pro-link {
    border-left: 4px solid #f39c12;
}

.dark-mode .radar-link {
    border-left: 4px solid #2980b9;
}

.dark-mode .pro-link {
    border-left: 4px solid #d35400;
}

@media (max-width: 768px) {
  

    
    select, input {
        width: 100%;
    }
    
    /* Make text elements more readable on mobile */
    .x-label, .y-label {
        font-size: 12px;
    }
    
    /* Adjust tooltip position for mobile */
    .tooltip {
        max-width: 80%;
    }
    
    /* Adjust promo links for mobile */
    .promo-links-container {
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 0 15px;
    }
}

    </style>

  <header class="header">
    <div class="logo">
      <a href="https://datamb.football">
        <img src="https://datamb.football/logo.png" alt="Football team statistics comparison. Radar comparison tool. Visualise and compare team data from the top 7 leagues : Premier League, La Liga, Bundesliga, Serie A, Ligue 1, Eredivisie, Primeira Liga" /></a>
        <div class="logo-text"><a href="https://datamb.football">&nbsp;Teams</a></div>
    </div>
    <nav class="navigation">
      <a href="https://datamb.football/teams" class="button10" data-i18n="header.home">Home</a>
      <a href="https://datamb.football/join" class="button10" data-i18n="header.pro">Pro</a>
      <a href="https://datamb.football/guide" class="button10" data-i18n="header.guide">Guide</a>
    </nav>
    <div class="header-right">
    <div class="search-container">
      <button id="searchButton3"><iconify-icon icon="ion:search-outline"></iconify-icon></button>
  </div>
    <div class="language-switcher-container">
      <button class="language-button" id="languageButton">
        <iconify-icon icon="heroicons:globe-alt"></iconify-icon>
      </button>
      <div class="language-dropdown" id="languageDropdown">
        <a href="?lang=en" class="language-option"><iconify-icon icon="flag:gb-4x3"></iconify-icon>English</a>
      </div>
    </div></div>
  </header>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7677714701428206"
     crossorigin="anonymous"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-PSBMXX80EF"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PSBMXX80EF');
</script>
</head>
<div class="search-input-modal" id="searchInputModal">
    <div class="search-input-container">
        <input type="text" id="searchInput" data-i18n="search.placeholder" placeholder="Enter a team or player name...">
        <div id="autocompleteBox"></div>
    </div>
</div>
<script>
    const xhr1 = new XMLHttpRequest();
  xhr1.open('GET', 'https://datamb.football/database/searchbar.csv', false); // false for synchronous request
  xhr1.send(null);
  
  let dataCSV = xhr1.responseText;
    
function _0x5707(_0xd20fa7,_0x4d36b5){const _0x4dcd69=_0x4dcd();return _0x5707=function(_0x57077a,_0xde96b9){_0x57077a=_0x57077a-0x140;let _0x383e81=_0x4dcd69[_0x57077a];return _0x383e81;},_0x5707(_0xd20fa7,_0x4d36b5);}const _0xedf2b2=_0x5707;(function(_0x16e1b0,_0x125833){const _0x222c5a=_0x5707,_0x3f540c=_0x16e1b0();while(!![]){try{const _0x3105f2=parseInt(_0x222c5a(0x161))/0x1+parseInt(_0x222c5a(0x144))/0x2+parseInt(_0x222c5a(0x148))/0x3+-parseInt(_0x222c5a(0x155))/0x4+parseInt(_0x222c5a(0x141))/0x5*(-parseInt(_0x222c5a(0x145))/0x6)+-parseInt(_0x222c5a(0x157))/0x7+parseInt(_0x222c5a(0x14b))/0x8*(parseInt(_0x222c5a(0x159))/0x9);if(_0x3105f2===_0x125833)break;else _0x3f540c['push'](_0x3f540c['shift']());}catch(_0x450250){_0x3f540c['push'](_0x3f540c['shift']());}}}(_0x4dcd,0x1bc51));const dataLines=dataCSV[_0xedf2b2(0x160)]('\x0a'),searchButton3=document[_0xedf2b2(0x142)]('searchButton3'),searchInputModal=document[_0xedf2b2(0x142)](_0xedf2b2(0x14a)),searchInput=document[_0xedf2b2(0x142)](_0xedf2b2(0x143)),autocompleteBox=document[_0xedf2b2(0x142)](_0xedf2b2(0x162)),data11=dataLines[_0xedf2b2(0x146)](_0x19546c=>{const _0x89300c=_0xedf2b2,[_0x5af128,_0x515bec]=_0x19546c[_0x89300c(0x160)](',');return{'name':_0x5af128,'link':_0x515bec};});function removeDiacritics(_0x3ed1af){const _0x202611=_0xedf2b2,_0x4b45cf={'ø':'o','Ø':'O','ı':'i'};return _0x3ed1af=_0x3ed1af[_0x202611(0x147)](/[øØıI]/g,_0x19f74a=>_0x4b45cf[_0x19f74a]),_0x3ed1af[_0x202611(0x15d)]('NFD')[_0x202611(0x147)](/[\u0300-\u036f]/g,'');}function search2(_0x1db14d){const _0x26c944=_0xedf2b2;autocompleteBox[_0x26c944(0x15e)]='';const _0x321867=removeDiacritics(_0x1db14d)[_0x26c944(0x147)](/[^\w\s]/g,'')[_0x26c944(0x149)](),_0x3ad89e=data11[_0x26c944(0x15c)](_0xb995bf=>{const _0x3866b0=_0x26c944,_0x2b7de7=removeDiacritics(_0xb995bf[_0x3866b0(0x14e)])['replace'](/[^\w\s]/g,'')[_0x3866b0(0x149)]();return _0x2b7de7['includes'](_0x321867);});if(_0x3ad89e[_0x26c944(0x163)]===0x0){autocompleteBox[_0x26c944(0x152)][_0x26c944(0x14c)]='none';return;}_0x3ad89e[_0x26c944(0x151)](_0x4b9def=>{const _0x31eeb1=_0x26c944,_0x505ab8=document[_0x31eeb1(0x14d)]('div'),_0x3a2d70=document[_0x31eeb1(0x14d)]('a');_0x3a2d70['href']=_0x4b9def[_0x31eeb1(0x154)],_0x3a2d70[_0x31eeb1(0x150)]=_0x4b9def[_0x31eeb1(0x14e)],_0x505ab8[_0x31eeb1(0x15b)](_0x3a2d70),autocompleteBox[_0x31eeb1(0x15b)](_0x505ab8);}),autocompleteBox['style'][_0x26c944(0x14c)]=_0x26c944(0x153);}searchButton3[_0xedf2b2(0x156)](_0xedf2b2(0x14f),()=>{const _0x350b96=_0xedf2b2;searchInputModal['style'][_0x350b96(0x14c)]=_0x350b96(0x153);}),searchInput['addEventListener'](_0xedf2b2(0x158),()=>{const _0x122364=_0xedf2b2,_0x1aac33=searchInput['value'];_0x1aac33[_0x122364(0x140)]()===''?autocompleteBox[_0x122364(0x152)][_0x122364(0x14c)]='none':search2(_0x1aac33);}),document['addEventListener']('click',_0x17873a=>{const _0x2c2a21=_0xedf2b2;_0x17873a[_0x2c2a21(0x15a)]===searchInputModal&&(searchInputModal[_0x2c2a21(0x152)][_0x2c2a21(0x14c)]=_0x2c2a21(0x15f));});function _0x4dcd(){const _0x3abacf=['forEach','style','block','link','165476bdcaHI','addEventListener','430668iEzpyY','input','90cmGEmO','target','appendChild','filter','normalize','innerHTML','none','split','102625kyWWmb','autocompleteBox','length','trim','5KymJaR','getElementById','searchInput','423476PJmBDe','1170534HGXHHf','map','replace','60222cRWbFM','toLowerCase','searchInputModal','61832bbygIm','display','createElement','name','click','textContent'];_0x4dcd=function(){return _0x3abacf;};return _0x4dcd();}
  
  
  
  </script>


<body>
    <div class="container">
        <div class="chart-wrapper">
            <div class="controls">
                <select id="select-x" style="display: none;"></select>
                <select id="select-y" style="display: none;"></select>
                <select id="select-league" style="display: none;" onchange="updateChart()">
                    <option value="all">Top 7 Leagues</option>
                    <option value="Top 5 Leagues">Top 5 Leagues</option>
                    <option value="Premier League">Premier League</option>
                    <option value="La Liga">La Liga</option>
                    <option value="Bundesliga">Bundesliga</option>
                    <option value="Serie A">Serie A</option> 
                    <option value="Ligue 1">Ligue 1</option>
                    <option value="Eredivisie">Eredivisie</option>
                    <option value="Primeira Liga">Liga Portugal</option>
                </select>
                
                <!-- Custom X metric selector -->
                <div class="metric-select-container">
                    <div class="metric-select-trigger" id="x-metric-trigger">
                        <span data-i18n="metrics.goals-per-90">Goals per 90</span>
                    </div>
                    <div class="metric-select-options" id="x-metric-options">
                        <!-- Options will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Custom Y metric selector -->
                <div class="metric-select-container">
                    <div class="metric-select-trigger" id="y-metric-trigger">
                        <span data-i18n="metrics.xg-per-90">xG per 90</span>
                    </div>
                    <div class="metric-select-options" id="y-metric-options">
                        <!-- Options will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Custom league selector with flag icons -->
                <div class="custom-select-container">
                    <div class="custom-select-trigger" id="league-select-trigger">
                        <iconify-icon icon="emojione:flag-for-flag-european-union" width="18" height="18"></iconify-icon>
                        <span data-i18n="leagues.top7">Top 7 Leagues</span>
                    </div>
                    <div class="custom-select-options" id="league-select-options">
                        <div class="custom-select-option selected" data-value="all">
                            <iconify-icon icon="emojione:flag-for-flag-european-union" width="18" height="18"></iconify-icon>
                            <span data-i18n="leagues.top7">Top 7 Leagues</span>
                        </div>
                        <div class="custom-select-option" data-value="Top 5 Leagues">
                            <iconify-icon icon="emojione:flag-for-flag-european-union" width="18" height="18"></iconify-icon>
                            <span data-i18n="leagues.top5">Top 5 Leagues</span>
                        </div>
                        <div class="custom-select-option" data-value="Premier League">
                            <iconify-icon icon="emojione:flag-for-united-kingdom" width="18" height="18"></iconify-icon>
                            <span>Premier League</span>
                        </div>
                        <div class="custom-select-option" data-value="La Liga">
                            <iconify-icon icon="emojione:flag-for-spain" width="18" height="18"></iconify-icon>
                            <span>La Liga</span>
                        </div>
                        <div class="custom-select-option" data-value="Bundesliga">
                            <iconify-icon icon="emojione:flag-for-germany" width="18" height="18"></iconify-icon>
                            <span>Bundesliga</span>
                        </div>
                        <div class="custom-select-option" data-value="Serie A">
                            <iconify-icon icon="emojione:flag-for-italy" width="18" height="18"></iconify-icon>
                            <span>Serie A</span>
                        </div>
                        <div class="custom-select-option" data-value="Ligue 1">
                            <iconify-icon icon="emojione:flag-for-france" width="18" height="18"></iconify-icon>
                            <span>Ligue 1</span>
                        </div>
                        <div class="custom-select-option" data-value="Eredivisie">
                            <iconify-icon icon="emojione:flag-for-netherlands" width="18" height="18"></iconify-icon>
                            <span>Eredivisie</span>
                        </div>
                        <div class="custom-select-option" data-value="Primeira Liga">
                            <iconify-icon icon="emojione:flag-for-portugal" width="18" height="18"></iconify-icon>
                            <span>Liga Portugal</span>
                        </div>
                    </div>
                </div>
                
                <input type="text" id="search-bar" data-i18n="search.placeholder2" placeholder="Search team...">
                <div class="btn-tooltip">
                    <button id="toggle-median-lines" class="btn btn-outline btn-icon">
                        <div class="icon">
                            <i class="ion-stats-bars"></i>
                        </div>
                    </button>
                    <span class="btn-tooltip-text" id="median-lines-tooltip" data-i18n="tooltip.median-lines">Show median lines</span>
                </div>
                <div class="btn-tooltip">
                    <button class="btn btn-outline btn-icon" id="select-all-button" onclick="selectAllCircles()">
                        <div class="icon">
                            <i class="ion-ios-circle-filled" id="select-icon"></i>
                        </div>
                    </button>
                    <span class="btn-tooltip-text" id="select-all-tooltip" data-i18n="tooltip.select-all">Select all teams</span>
                </div>
                <div class="btn-tooltip">
                    <button class="btn btn-outline btn-icon" onclick="takeScreenshot()">
                        <div class="icon">
                            <i class="ion-camera"></i>
                        </div>
                    </button>
                    <span class="btn-tooltip-text" data-i18n="tooltip.screenshot">Download chart as image</span>
                </div>
            </div>
       
            <div class="chart-container">
              <svg id="scatter-plot"></svg>
            </div>

            <div class="legend" id="league-legend">
              <!-- Legend items will be added here dynamically -->
            </div>
        </div>

        <div class="promo-links-container">
            <a href="https://datamb.football/teamradars" class="promo-link radar-link">
                <iconify-icon icon="mdi:radar" width="20" height="20"></iconify-icon>
                <span data-i18n="promo.radar-link">Compare Teams with Radars</span>
            </a>
            <a href="https://datamb.football/join" class="promo-link pro-link">
                <iconify-icon icon="mdi:account-star" width="20" height="20"></iconify-icon>
                <span data-i18n="promo.pro-link">Get Pro for Player Plots</span>
            </a>
            <div class="dark-mode-toggle pc-only" onclick="toggleDarkMode()">
                <div class="toggle-icon"></div>
            </div>
        </div>
    </div>

    <div class="dark-mode-toggle mobile-only" onclick="toggleDarkMode()">
        <div class="toggle-icon"></div>
    </div>

    <script>
        
        let initializeCustomSelectors = function() {
            // League selector functionality
            const leagueTrigger = document.getElementById('league-select-trigger');
            const leagueOptions = document.getElementById('league-select-options');
            const leagueSelect = document.getElementById('select-league');
            
            setupCustomSelect(leagueTrigger, leagueOptions, leagueSelect);
            
            // X metric selector functionality
            const xTrigger = document.getElementById('x-metric-trigger');
            const xOptions = document.getElementById('x-metric-options');
            const xSelect = document.getElementById('select-x');
            
            // Populate X metric options
            populateMetricOptions(xOptions, header.slice(3), function(option, value) {
                if (xTrigger.querySelector('span').textContent === value) {
                    option.classList.add('selected');
                }
                if (value === header[3]) { // Default value
                    option.classList.add('selected');
                    // Update trigger text
                    xTrigger.querySelector('span').textContent = value;
                    const metricKey = value.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                    xTrigger.querySelector('span').setAttribute('data-i18n', 'metrics.' + metricKey);
                }
            });
            
            setupCustomSelect(xTrigger, xOptions, xSelect);
            
            // Y metric selector functionality
            const yTrigger = document.getElementById('y-metric-trigger');
            const yOptions = document.getElementById('y-metric-options');
            const ySelect = document.getElementById('select-y');
            
            // Populate Y metric options
            populateMetricOptions(yOptions, header.slice(3), function(option, value) {
                if (yTrigger.querySelector('span').textContent === value) {
                    option.classList.add('selected');
                }
                if (value === header[4]) { // Default value
                    option.classList.add('selected');
                    // Update trigger text
                    yTrigger.querySelector('span').textContent = value;
                    const metricKey = value.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                    yTrigger.querySelector('span').setAttribute('data-i18n', 'metrics.' + metricKey);
                }
            });
            
            setupCustomSelect(yTrigger, yOptions, ySelect);
        };
        
        // Function to populate metric options
        function populateMetricOptions(optionsContainer, metrics, callback) {
            // Clear existing options
            optionsContainer.innerHTML = '';
            
            // Create a custom option for each metric
            metrics.forEach(function(metric) {
                const customOption = document.createElement('div');
                customOption.className = 'metric-select-option';
                customOption.setAttribute('data-value', metric);
                
                const span = document.createElement('span');
                span.textContent = metric;
                
                // Add data-i18n attribute for translation
                const metricKey = metric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                span.setAttribute('data-i18n', 'metrics.' + metricKey);
                
                customOption.appendChild(span);
                
                // Call the callback to potentially add selected class
                if (callback) callback(customOption, metric);
                
                optionsContainer.appendChild(customOption);
            });
        }
        
        // Function to set up a custom select
        function setupCustomSelect(trigger, options, selectElement) {
            // Toggle dropdown when clicking the trigger
            trigger.addEventListener('click', function() {
                // Close all other open dropdowns first
                document.querySelectorAll('.custom-select-trigger.open, .metric-select-trigger.open').forEach(function(openTrigger) {
                    if (openTrigger !== trigger) {
                        openTrigger.classList.remove('open');
                        const openOptions = openTrigger.nextElementSibling;
                        if (openOptions) openOptions.style.display = 'none';
                    }
                });
                
                // Toggle this dropdown
                trigger.classList.toggle('open');
                const isOpen = trigger.classList.contains('open');
                options.style.display = isOpen ? 'block' : 'none';
            });
            
            // Handle option selection
            const optionElements = options.querySelectorAll('.custom-select-option, .metric-select-option');
            optionElements.forEach(option => {
                option.addEventListener('click', function() {
                    // Update selected option
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                    
                    // Update trigger content
                    const text = this.querySelector('span').textContent;
                    const dataI18n = this.querySelector('span').getAttribute('data-i18n');
                    const icon = this.querySelector('iconify-icon');
                    
                    trigger.innerHTML = '';
                    
                    if (icon) {
                        const clonedIcon = icon.cloneNode(true);
                        clonedIcon.style.marginRight = '8px';
                        trigger.appendChild(clonedIcon);
                    }
                    
                    const span = document.createElement('span');
                    span.textContent = text;
                    if (dataI18n) {
                        span.setAttribute('data-i18n', dataI18n);
                    }
                    trigger.appendChild(span);
                    
                    // Update hidden select and trigger change event
                    const value = this.getAttribute('data-value');
                    selectElement.value = value || text;
                    
                    // Trigger the change event on the hidden select
                    const event = new Event('change');
                    selectElement.dispatchEvent(event);
                    
                    // Close dropdown
                    trigger.classList.remove('open');
                    options.style.display = 'none';
                });
            });
            
            // Add keyboard navigation
            let searchTerm = '';
            let searchTimeout;
            
            // Add keydown event listener to the document
            document.addEventListener('keydown', function(e) {
                // Only process keyboard input when dropdown is open
                if (!trigger.classList.contains('open')) return;
                
                // Handle arrow keys for navigation
                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    
                    const visibleOptions = Array.from(optionElements);
                    const currentIndex = visibleOptions.findIndex(opt => opt.classList.contains('selected'));
                    let newIndex;
                    
                    if (e.key === 'ArrowDown') {
                        newIndex = currentIndex < visibleOptions.length - 1 ? currentIndex + 1 : 0;
                    } else {
                        newIndex = currentIndex > 0 ? currentIndex - 1 : visibleOptions.length - 1;
                    }
                    
                    // Update selection
                    optionElements.forEach(opt => opt.classList.remove('selected'));
                    visibleOptions[newIndex].classList.add('selected');
                    
                    // Ensure the selected option is visible in the dropdown
                    visibleOptions[newIndex].scrollIntoView({ block: 'nearest' });
                    
                    return;
                }
                
                // Handle Enter key to select the currently highlighted option
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const selectedOption = options.querySelector('.selected');
                    if (selectedOption) {
                        selectedOption.click();
                    }
                    return;
                }
                
                // Handle Escape key to close the dropdown
                if (e.key === 'Escape') {
                    e.preventDefault();
                    trigger.classList.remove('open');
                    options.style.display = 'none';
                    return;
                }
                
                // Handle typing to search
                if (e.key.length === 1 && e.key.match(/[a-zA-Z0-9%]/)) {
                    // Clear the previous timeout
                    clearTimeout(searchTimeout);
                    
                    // Add the key to the search term
                    searchTerm += e.key.toLowerCase();
                    
                    // Find the first option that starts with the search term
                    const matchingOption = Array.from(optionElements).find(option => {
                        const optionText = option.querySelector('span').textContent.toLowerCase();
                        return optionText.startsWith(searchTerm);
                    });
                    
                    // If a matching option is found, select it
                    if (matchingOption) {
                        optionElements.forEach(opt => opt.classList.remove('selected'));
                        matchingOption.classList.add('selected');
                        matchingOption.scrollIntoView({ block: 'nearest' });
                    }
                    
                    // Clear the search term after a delay
                    searchTimeout = setTimeout(() => {
                        searchTerm = '';
                    }, 1000);
                }
            });
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const triggers = document.querySelectorAll('.custom-select-trigger, .metric-select-trigger');
            const optionsContainers = document.querySelectorAll('.custom-select-options, .metric-select-options');
            
            let clickedInsideDropdown = false;
            
            triggers.forEach(function(trigger, index) {
                const options = optionsContainers[index];
                
                if (trigger && options && (trigger.contains(e.target) || options.contains(e.target))) {
                    clickedInsideDropdown = true;
                }
            });
            
            if (!clickedInsideDropdown) {
                triggers.forEach(function(trigger, index) {
                    if (trigger && optionsContainers[index]) {
                        trigger.classList.remove('open');
                        optionsContainers[index].style.display = 'none';
                    }
                });
            }
        });



   
        // Load the data
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'https://datamb.football/database/TEAM/teamplots.csv', false);
        xhr.send(null);
        
        let csvData = xhr.responseText;
        
        let extraHeaderRow = 'ID,Player,Top 7 Leagues,Goals per 90,xG per 90,Shots on target per 90,Shots on target %,Passes completed,Pass accuracy %,Possession %,Positional attacks per 90,Counter attacks per 90,Touches in the box per 90,Goals conceded per 90,SoT against per 90,Defensive duels per 90,Defensive duel %,Aerial duels per 90,Aerial duels %,Passes per possession,PPDA\n';
        
        // Concatenate the extra header row with the fetched CSV data
        csvData = extraHeaderRow + csvData;
        
        var rows = csvData.trim().split('\n');
        var header = rows[0].split(',');
        var data = rows.slice(1).map(function(row) {
            return row.split(',').map(function(d, i) {
                if (i >= 3) {
                    return parseFloat(d);
                } else {
                    return d;
                }
            });
        });
        
        var margin = { top: 0, right: 0, bottom: 0, left: 0 };
        var width = 1082 - margin.left - margin.right;
        var height = 770 - margin.top - margin.bottom;
        
        // Define league colors for clicked circles
        var leagueColors = {
            "Premier League": "rgba(255, 0, 0, 0.7)",      // Red
            "La Liga": "rgba(255, 165, 0, 0.7)",           // Orange
            "Bundesliga": "rgba(255, 255, 0, 0.7)",        // Yellow
            "Serie A": "rgba(0, 128, 0, 0.7)",             // Green
            "Ligue 1": "rgba(0, 0, 255, 0.7)",             // Blue
            "Eredivisie": "rgba(75, 0, 130, 0.7)",         // Indigo
            "Primeira Liga": "rgba(238, 130, 238, 0.7)"    // Violet
        };

        // Function to get color based on league
        function getLeagueColor(league) {
            return leagueColors[league] || "rgba(255, 0, 0, 0.7)"; // Default to red if league not found
        }
        
        // Calculate container width to center the chart
        function updateChartDimensions() {
            var containerWidth = document.querySelector('.chart-wrapper').clientWidth;
            var containerHeight = window.innerHeight * 0.7; // Use 70% of viewport height as max height
            
            // Set consistent side margins regardless of screen size
            var sideMargin = 30; // Consistent side margin in pixels
            var svgWidth = Math.min(1082, containerWidth - (sideMargin * 2));
            
            // Detect if we're on a vertical screen (mobile)
            var isVerticalScreen = window.innerWidth / window.innerHeight < 1;
            
            // Set consistent margins that work for both orientations
            if (isVerticalScreen) {
                // Mobile/vertical layout
                margin = { 
                    top: 40,          // Space for title/labels
                    right: 30, // Consistent right margin
                    bottom: 60,       // Space for x-axis labels
                    left: 75          // Space for y-axis labels
                };
                
                // For vertical screens, make the chart taller
                var verticalAspectRatio = 1.4; // Taller than wide
                var svgHeight = Math.min(containerHeight, svgWidth * verticalAspectRatio);
                
                // Ensure minimum height for mobile
                svgHeight = Math.max(svgHeight, 500);
            } else {
                // Desktop/horizontal layout
                margin = { 
                    top: 40,          // Space for title/labels
                    right: 30, // Consistent right margin
                    bottom: 60,       // Space for x-axis labels
                    left: 79         // Space for y-axis labels
                };
                
                // For horizontal screens, use a fixed aspect ratio
                var horizontalAspectRatio = 0.7; // Width:height ratio
                var svgHeight = svgWidth * horizontalAspectRatio;
            }
            
            // Update dimensions
            width = svgWidth - margin.left - margin.right;
            height = svgHeight - margin.top - margin.bottom;
            
            // Update SVG dimensions
            d3.select("#scatter-plot")
                .attr("width", svgWidth)
                .attr("height", svgHeight);
                
            // Update the chart container to match SVG size
            document.querySelector('.chart-container').style.height = svgHeight + 'px';
        }
        
        window.addEventListener('resize', function() {
            // Update dimensions immediately
            updateChartDimensions();
            // Use requestAnimationFrame for smoother updates
            requestAnimationFrame(function() {
                updateChart(); // Redraw the chart with new dimensions
            });
        });

        // Initial call to set dimensions
        updateChartDimensions();
        
        // Debounce function to limit how often the resize handler fires
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(function() {
                    func.apply(context, args);
                }, wait);
            };
        }
        
        // Track previous window dimensions to detect orientation changes
        var prevWindowWidth = window.innerWidth;
        var prevWindowHeight = window.innerHeight;
        
        // Add debounced resize handler
        window.addEventListener('resize', debounce(function() {
            // Check if orientation has changed (width/height ratio flipped)
            var wasVertical = prevWindowWidth / prevWindowHeight < 1;
            var isVertical = window.innerWidth / window.innerHeight < 1;
            
            // Update previous dimensions
            prevWindowWidth = window.innerWidth;
            prevWindowHeight = window.innerHeight;
            
              // Always update the chart on resize - use requestAnimationFrame for smoother updates
              requestAnimationFrame(function() {
                updateChart();
            });
        }, 50)); // Use a much shorter wait time for more responsive feel
        

        var medianLinesVisible = false;
        
        var selectX = d3.select("#select-x");
        var selectY = d3.select("#select-y");
        
        var names = data.map(function(row) {
            return row[1];
        });
        
        // Populate the select dropdowns
        header.slice(3).forEach(function(metric) {
            selectX.append("option")
                .text(metric)
                .attr("value", metric);
            selectY.append("option")
                .text(metric)
                .attr("value", metric);
        });
        
        // Set default values for the selectors
        selectX.property("value", header[3]);
        selectY.property("value", header[4]);
        
        // Create the SVG container
        var svg = d3.select("#scatter-plot")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        
        var xMetric = header[3];
        var yMetric = header[4]; // Use a different default for Y axis
        
        var xScale = d3.scaleLinear()
            .range([0, width]);
        var yScale = d3.scaleLinear()
            .range([height, 0]);
        
        var xAxis = d3.axisBottom(xScale).tickSize(0);
        var yAxis = d3.axisLeft(yScale).tickSize(0);
        
        // Add X axis
        var gXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + height + ")");
        
        // Add Y axis
        var gYAxis = svg.append("g")
            .attr("class", "y-axis");
        
        // Add axis labels
        var xLabel = svg.append("text")
            .attr("class", "x-label")
            .attr("text-anchor", "end")
            .attr("x", width)
            .attr("y", height + 35)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        var yLabel = svg.append("text")
            .attr("class", "y-label")
            .attr("text-anchor", "end")
            .attr("transform", "rotate(-90)")
            .attr("y", -53)
            .attr("x", 0)
            .style("font-family", "Inter, sans-serif")
            .style("font-size", "14px");
        
        // Create tooltip
        var tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip");
        
        // Function to check if device is mobile
        function isMobileDevice() {
            return window.innerWidth <= 768;
        }

        // Function to position tooltip to prevent overflow
        function positionTooltip(event, tooltipElement) {
            const tooltipNode = tooltipElement.node();
            if (!tooltipNode) return { left: 0, top: 0 };
            
            const tooltipRect = tooltipNode.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Default position
            let left = event.pageX + 10;
            let top = event.pageY - 28;
            
            // Adjust if tooltip would overflow right edge
            if (left + tooltipRect.width > viewportWidth - 10) {
                left = event.pageX - tooltipRect.width - 10;
            }
            
            // Adjust if tooltip would overflow bottom edge
            if (top + tooltipRect.height > viewportHeight - 10) {
                top = event.pageY - tooltipRect.height - 10;
            }
            
            // Ensure tooltip doesn't go off the left or top edge
            left = Math.max(10, left);
            top = Math.max(10, top);
            
            return { left, top };
        }

        var clickedCircles = [];
        var filteredData = data;
        var filteredNames = names;
        var circles;
        
        // Function to update the chart
        function updateChart() {
            // Update chart dimensions based on current window size
            updateChartDimensions();
            
            // Update SVG dimensions without recreating it
            d3.select("#scatter-plot")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom);
                
            // Update axis positions based on new dimensions
            gXAxis.attr("transform", "translate(0," + height + ")");
            xLabel.attr("x", width)
                  .attr("y", height + 35);
            yLabel.attr("x", 0);
            
            // Check if dark mode is active
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            // Get the selected league
            var selectedLeague = document.getElementById("select-league").value;
            
            
            // Filter data based on selected league
            if (selectedLeague === "all") {
                filteredData = data;
            } else if (selectedLeague === "Top 5 Leagues") {
                filteredData = data.filter(function(d) {
                    return d[2] === "Premier League" || d[2] === "La Liga" || 
                           d[2] === "Bundesliga" || d[2] === "Serie A" || 
                           d[2] === "Ligue 1";
                });
            } else {
                filteredData = data.filter(function(d) {
                    return d[2] === selectedLeague;
                });
            }
            
            // Update filtered names
            filteredNames = filteredData.map(function(d) {
                return d[1];
            });
            
            // Get the selected metrics
            xMetric = selectX.property("value");
            yMetric = selectY.property("value");
            
          // Update scales with consistent 10% padding on each side
          xScale.range([0, width])
                  .domain(function() {
                      const min = d3.min(filteredData, d => d[header.indexOf(xMetric)]);
                      const max = d3.max(filteredData, d => d[header.indexOf(xMetric)]);
                      const range = max - min;
                      
                      // Always use 10% of range as padding on each side
                      const padding = range * 0.1;
                      
                      return [min - padding, max + padding];
                  }());

            yScale.range([height, 0])
                  .domain(function() {
                      const min = d3.min(filteredData, d => d[header.indexOf(yMetric)]);
                      const max = d3.max(filteredData, d => d[header.indexOf(yMetric)]);
                      const range = max - min;
                      
                      // Always use 10% of range as padding on each side
                      const padding = range * 0.1;
                      
                      return [min - padding, max + padding];
                  }());
            
            // Update axes
            gXAxis.call(d3.axisBottom(xScale).tickSize(0));
            gYAxis.call(d3.axisLeft(yScale).tickSize(0));
            
            // Create metric key for translation
            const xMetricKey = "metrics." + xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            const yMetricKey = "metrics." + yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
            
            // Set data-i18n attribute
            xLabel.attr("data-i18n", xMetricKey);
            yLabel.attr("data-i18n", yMetricKey);
            
            // Apply translations directly if available
            if (window.currentTranslations && window.currentTranslations.metrics) {
                const xTranslationKey = xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                const yTranslationKey = yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                
                const xTranslation = window.currentTranslations.metrics[xTranslationKey];
                const yTranslation = window.currentTranslations.metrics[yTranslationKey];
                
                xLabel.text(xTranslation || xMetric);
                yLabel.text(yTranslation || yMetric);
            } else {
                xLabel.text(xMetric);
                yLabel.text(yMetric);
            }

            // Remove existing circles and labels
            svg.selectAll("circle").remove();
            svg.selectAll(".team-label").remove();
            svg.selectAll(".xy-line").remove(); // Remove any existing diagonal reference line
            svg.selectAll(".xy-line-bg").remove(); // Remove line background
            svg.selectAll(".xy-line-label").remove(); // Remove line label
            svg.selectAll(".xy-line-label-bg").remove(); // Remove label background
            svg.selectAll(".performance-label").remove(); // Remove performance labels
            svg.selectAll("linearGradient#line-gradient").remove(); // Remove gradient definition
            svg.selectAll("marker#arrow-over, marker#arrow-under").remove(); // Remove arrow markers
            svg.selectAll(".xy-line-hover").remove(); // Remove hover detection element
            svg.selectAll(".median-line").remove(); // Always remove median lines before potentially redrawing them
            
            // Add diagonal reference line for xG vs Goals
            if ((xMetric === 'xG per 90' && yMetric === 'Goals per 90') || 
                (xMetric === 'Goals per 90' && yMetric === 'xG per 90')) {
                
                // Variable to track hover timer for the diagonal line
                var diagonalLineHoverTimer = null;
                
                // Calculate the intersection points for the x=y line
                var minX = d3.min(filteredData, function(d) { return d[header.indexOf(xMetric)]; });
                var maxX = d3.max(filteredData, function(d) { return d[header.indexOf(xMetric)]; });
                var minY = d3.min(filteredData, function(d) { return d[header.indexOf(yMetric)]; });
                var maxY = d3.max(filteredData, function(d) { return d[header.indexOf(yMetric)]; });
                
                // Get the smaller max between the x and y axes
                var maxVal = Math.min(maxX, maxY);
                
                // Get the larger min between the x and y axes
                var minVal = Math.max(minX, minY);
                
                // Now draw the line only within these bounds
                svg.append("line")
                    .attr("class", "xy-line")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "#2ecc71") // Simple green color
                    .style("stroke-width", "2")
                    .style("stroke-dasharray", "5,3");
                
                // Add invisible wider line for better hover detection
                svg.append("line")
                    .attr("class", "xy-line-hover")
                    .attr("x1", xScale(minVal))
                    .attr("y1", yScale(minVal))
                    .attr("x2", xScale(maxVal))
                    .attr("y2", yScale(maxVal))
                    .style("stroke", "transparent")
                    .style("stroke-width", "15")
                    .style("cursor", "help")
                    .on("mouseover", function() {
                        // Clear any existing timer
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                        }
                        
                        // Capture the event coordinates
                        var eventX = d3.event.pageX;
                        var eventY = d3.event.pageY;
                        
                        // Set a new timer with delay
                        diagonalLineHoverTimer = setTimeout(function() {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", 0.9);
                            
                            // Use the global getTranslation function
                            var tooltipContent = "<strong>" + getTranslation("tooltip.xg-line-title", "G = xG Line") + "</strong><br/>";
                            
                            // Check which axis is which and provide the correct explanation
                            if (xMetric === 'xG per 90' && yMetric === 'Goals per 90') {
                                tooltipContent += "<span>" + getTranslation("tooltip.xg-line-above", "Teams above this line are scoring more goals than expected.") + "</span><br/>" +
                                    "<span>" + getTranslation("tooltip.xg-line-below", "Teams below this line are scoring fewer goals than expected.") + "</span>";
                            } else {
                                tooltipContent += "<span>" + getTranslation("tooltip.xg-line-right", "Teams right of this line are scoring more goals than expected.") + "</span><br/>" +
                                    "<span>" + getTranslation("tooltip.xg-line-left", "Teams left of this line are scoring fewer goals than expected.") + "</span>";
                            }
                            
                            tooltip.html(tooltipContent)
                                .style("left", (eventX + 10) + "px")
                                .style("top", (eventY - 28) + "px");
                        }, 600); // 550ms delay before showing tooltip
                    })
                    .on("mouseout", function() {
                        // Clear the timer if mouse leaves before tooltip is shown
                        if (diagonalLineHoverTimer) {
                            clearTimeout(diagonalLineHoverTimer);
                            diagonalLineHoverTimer = null;
                        }
                        
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
            }
            
            // Add median lines if enabled
            if (medianLinesVisible) {
                // Calculate medians
                var xMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(xMetric)]; 
                });
                
                var yMedian = d3.median(filteredData, function(d) { 
                    return d[header.indexOf(yMetric)]; 
                });
                
                // Add X median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", xScale(xMedian))
                    .attr("y1", 0)
                    .attr("x2", xScale(xMedian))
                    .attr("y2", height)
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
                
                // Add Y median line
                svg.append("line")
                    .attr("class", "median-line")
                    .attr("x1", 0)
                    .attr("y1", yScale(yMedian))
                    .attr("x2", width)
                    .attr("y2", yScale(yMedian))
                    .style("stroke", "rgba(0, 0, 0, 0.3)")
                    .style("stroke-dasharray", "4");
            }
            
            // Add circles
            circles = svg.selectAll("circle")
                .data(filteredData)
                .enter()
                .append("circle")
                .attr("cx", function(d) { return xScale(d[header.indexOf(xMetric)]); })
                .attr("cy", function(d) { return yScale(d[header.indexOf(yMetric)]); })
                .attr("r", 8)
                .style("fill", function(d) {
                    // Check if this circle is in the clicked circles array
                    if (clickedCircles.includes(d[1])) {
                        return getLeagueColor(d[2]);
                    }
                    return "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("cursor", "pointer")
                .on("mouseover", function(d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 10)
                        .style("fill", getLeagueColor(d[2])); // Show league color on hover
                    
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", 0.9);
                    
                    // Create metric keys for translation
                    const xMetricKey = "metrics." + xMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                    const yMetricKey = "metrics." + yMetric.toLowerCase().replace(/ /g, '-').replace(/%/g, 'pct');
                    
                    // Get translated metric names using the global getTranslation function
                    const xMetricTranslated = getTranslation(xMetricKey, xMetric);
                    const yMetricTranslated = getTranslation(yMetricKey, yMetric);
                    
                    tooltip.html("<strong>" + d[1] + "</strong><br/>" +
                        xMetricTranslated + ": " + d[header.indexOf(xMetric)].toFixed(2) + "<br/>" +
                        yMetricTranslated + ": " + d[header.indexOf(yMetric)].toFixed(2));

                    // Position tooltip to prevent overflow
                    const tooltipNode = tooltip.node();
                    if (tooltipNode) {
                        const tooltipRect = tooltipNode.getBoundingClientRect();
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;
                        
                        // Default position
                        let left = d3.event.pageX + 10;
                        let top = d3.event.pageY - 28;
                        
                        // Adjust if tooltip would overflow right edge
                        if (left + tooltipRect.width > viewportWidth - 10) {
                            left = d3.event.pageX - tooltipRect.width - 10;
                        }
                        
                        // Adjust if tooltip would overflow bottom edge
                        if (top + tooltipRect.height > viewportHeight - 10) {
                            top = d3.event.pageY - tooltipRect.height - 10;
                        }
                        
                        // Ensure tooltip doesn't go off the left or top edge
                        left = Math.max(10, left);
                        top = Math.max(10, top);
                        
                        tooltip.style("left", left + "px")
                               .style("top", top + "px");
                    } else {
                        tooltip.style("left", (d3.event.pageX + 10) + "px")
                               .style("top", (d3.event.pageY - 28) + "px");
                    }
                    
                    // On mobile, hide tooltip after 1 second
                    if (window.innerWidth <= 768) {
                        setTimeout(function() {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", 0);
                        }, 1000);
                    }
                })
                .on("mouseout", function(d) {
                    // Only hide tooltip on non-mobile devices (mobile has timeout)
                    if (window.innerWidth > 768) {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    }
                    
                    // Get the original fill color
                    var isClicked = clickedCircles.includes(d[1]);
                    
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr("r", 8)
                        .style("fill", function() {
                            // If the circle is clicked, keep the league color
                            // Otherwise, revert to the default blue
                            return isClicked ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                        });
                })
                .on("click", function(d) {
                    // Check if this is a search match
                    var isSearchMatch = d3.select(this).classed("search-match");
                    
                    // If it's a search match, clear the search first
                    if (isSearchMatch) {
                        resetSearch();
                    }
                    
                    // Toggle clicked state
                    var index = clickedCircles.indexOf(d[1]);
                    
                    if (index === -1) {
                        // Add to clicked circles
                        clickedCircles.push(d[1]);
                        d3.select(this)
                            .style("fill", getLeagueColor(d[2]))
                            .style("stroke", "#000")
                            .style("stroke-width", 2);
                            
                        // Add team label
                        addTeamLabel(d);
                    } else {
                        // Remove from clicked circles
                        clickedCircles.splice(index, 1);
                        d3.select(this)
                            .style("fill", "rgba(70, 130, 180, 0.7)")
                            .style("stroke", "none");
                            
                        // Remove team label
                        svg.selectAll(".team-label-" + d[1].replace(/\s+/g, '-').toLowerCase()).remove();
                    }
                    
                    // Update button text based on whether all circles are selected
                    updateSelectAllButtonText();
                    
                    // Update the legend
                    var selectedLeague = document.getElementById("select-league").value;
                    updateLeagueLegend(selectedLeague);
                });
                
            // Add labels for clicked teams
            clickedCircles.forEach(function(teamName) {
                var teamData = filteredData.find(function(d) {
                    return d[1] === teamName;
                });
                
                if (teamData) {
                    addTeamLabel(teamData);
                }
            });
                
            // Update button text based on current selection state
            updateSelectAllButtonText();
            
            // Update the legend to show only relevant leagues
            updateLeagueLegend(selectedLeague);
        }
        
        // Function to update the "Click All" button icon
        function updateSelectAllButtonText() {
            var selectIcon = document.getElementById('select-icon');
            var selectTooltip = document.getElementById('select-all-tooltip');
            var allSelected = filteredData.every(function(d) {
                return clickedCircles.includes(d[1]);
            });
            
            if (allSelected) {
                selectIcon.className = "ion-ios-circle-outline"; // Icon for "Unclick All"
                if (selectTooltip) {
                    // Use translations for unselect all teams
                    if (window.currentTranslations && window.currentTranslations.tooltip) {
                        selectTooltip.textContent = window.currentTranslations.tooltip.unselectAll || "Unselect all teams";
                    } else {
                        selectTooltip.textContent = "Unselect all teams";
                    }
                }
            } else {
                selectIcon.className = "ion-ios-circle-filled"; // Icon for "Click All"
                if (selectTooltip) {
                    // Use translations for select all teams
                    if (window.currentTranslations && window.currentTranslations.tooltip) {
                        selectTooltip.textContent = window.currentTranslations.tooltip.selectAll || "Select all teams";
                    } else {
                        selectTooltip.textContent = "Select all teams";
                    }
                }
            }
        }
        
        // Add event listeners to the selectors
        selectX.on("change", updateChart);
        selectY.on("change", updateChart);
        
        // Function to remove special characters and diacritics for better search matching
        function removeSpecialCharsAndDiacritics(str) {
            if (!str) return '';
            return str.normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .replace(/Ø/g, 'O')
                .replace(/ø/g, 'o');
        }
        
        // Add search functionality
        var searchBar = document.getElementById("search-bar");
        
        searchBar.addEventListener("input", function() {
            var searchTerm = searchBar.value.toLowerCase();
            
            if (searchTerm === '') {
                resetSearch();
                return;
            }
            
            // Normalize search term to handle special characters and diacritics
            var normalizedSearchTerm = removeSpecialCharsAndDiacritics(searchTerm);
            
            // Reset previous search styling
            svg.selectAll("circle").classed("search-match", false)
                .style("fill", function(d) {
                    // Restore original fill color
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                });
            
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false);
            
            // Find matching teams
            var matchingTeams = [];
            
            // Apply new search styling
            svg.selectAll("circle").filter(function(d) {
                var teamName = d[1].toLowerCase();
                var normalizedTeamName = removeSpecialCharsAndDiacritics(teamName);
                
                // Check both original and normalized versions for better matching
                var isMatch = teamName.includes(searchTerm) || normalizedTeamName.includes(normalizedSearchTerm);
                
                if (isMatch) {
                    matchingTeams.push(d[1]);
                }
                
                return isMatch;
            })
            .classed("search-match", true)
            .each(function() {
                // Bring matching circles to front
                this.parentNode.appendChild(this);
            });
            
            // If we have matches, dim non-matching labels
            if (matchingTeams.length > 0) {
                // First dim all labels
                svg.selectAll(".team-label").classed("search-dimmed", true);
                
                // Then highlight matching labels
                svg.selectAll(".team-label").filter(function() {
                    var labelText = d3.select(this).text();
                    return matchingTeams.includes(labelText);
                })
                .classed("search-match", true)
                .classed("search-dimmed", false)
                .each(function() {
                    // Bring matching labels to front
                    this.parentNode.appendChild(this);
                });
                
                // Add labels for matching teams that don't have labels yet
                matchingTeams.forEach(function(teamName) {
                    // Check if this team already has a label
                    var labelClass = "team-label-" + teamName.replace(/\s+/g, '-').toLowerCase();
                    if (svg.select("." + labelClass).size() === 0) {
                        // Find the team data
                        var teamData = filteredData.find(function(d) {
                            return d[1] === teamName;
                        });
                        
                        if (teamData) {
                            // Add the label
                            addTeamLabel(teamData);
                            // Apply search match styling
                            svg.select("." + labelClass).classed("search-match", true);
                        }
                    }
                });
            } else {
                // No matches found - reset to default state
                // Remove all team labels that aren't for clicked circles
                svg.selectAll(".team-label").each(function() {
                    var label = d3.select(this);
                    var teamName = label.text();
                    
                    if (!clickedCircles.includes(teamName)) {
                        label.remove();
                    }
                });
                
                // Make sure clicked circles remain highlighted
                svg.selectAll("circle")
                    .style("fill", function(d) {
                        return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                    })
                    .style("stroke", function(d) {
                        return clickedCircles.includes(d[1]) ? "#000" : "none";
                    })
                    .style("stroke-width", function(d) {
                        return clickedCircles.includes(d[1]) ? 2 : 0;
                    });
            }
        });
        
        function resetSearch() {
            // Clear the search input field
            searchBar.value = '';
            
            // Reset circle styling
            svg.selectAll("circle")
                .classed("search-match", false)
                .style("fill", function(d) {
                    return clickedCircles.includes(d[1]) ? getLeagueColor(d[2]) : "rgba(70, 130, 180, 0.7)";
                })
                .style("stroke", function(d) {
                    return clickedCircles.includes(d[1]) ? "#000" : "none";
                })
                .style("stroke-width", function(d) {
                    return clickedCircles.includes(d[1]) ? 2 : 0;
                })
                .style("filter", "none")
                .each(function() {
                    // Reset any inline styles that might interfere with our animation
                    d3.select(this).style("r", null);
                    // Stop any ongoing animations
                    d3.select(this).interrupt();
                });
                
            // Reset label styling
            svg.selectAll(".team-label")
                .classed("search-match", false)
                .classed("search-dimmed", false)
                .each(function() {
                    // Stop any ongoing animations
                    d3.select(this).interrupt();
                });
                
            // Remove labels for teams that aren't clicked
            svg.selectAll(".team-label").each(function() {
                var label = d3.select(this);
                var teamName = label.text();
                
                if (!clickedCircles.includes(teamName)) {
                    label.remove();
                }
            });
        }
        
        // Toggle median lines
        var toggleButton = document.getElementById("toggle-median-lines");
        toggleButton.addEventListener("click", function() {
            medianLinesVisible = !medianLinesVisible;
            updateChart();

            const medianTooltip = document.getElementById('median-lines-tooltip');
            // Use translations for the median lines tooltip
            if (window.currentTranslations && window.currentTranslations.tooltip) {
                medianTooltip.textContent = medianLinesVisible ? 
                    (window.currentTranslations.tooltip.hideMedianLines || "Hide median lines") : 
                    (window.currentTranslations.tooltip.showMedianLines || "Show median lines");
            } else {
                medianTooltip.textContent = medianLinesVisible ? "Hide median lines" : "Show median lines";
            }
        });
        
        // Select all circles
        function selectAllCircles() {
            // Check if all circles are already selected
            var allSelected = filteredData.every(function(d) {
                return clickedCircles.includes(d[1]);
            });
            
            if (allSelected) {
                // Deselect all circles
                clickedCircles = [];
                svg.selectAll("circle")
                    .style("fill", "rgba(70, 130, 180, 0.7)")
                    .style("stroke", "none");
                
                // Remove all team labels
                svg.selectAll(".team-label").remove();
            } else {
                // Select all circles
                svg.selectAll("circle").each(function(d) {
                    if (!clickedCircles.includes(d[1])) {
                        clickedCircles.push(d[1]);
                        d3.select(this)
                            .style("fill", getLeagueColor(d[2]))
                            .style("stroke", "#000")
                            .style("stroke-width", 2);
                    }
                });
                
                // Add labels for all teams
                filteredData.forEach(function(d) {
                    addTeamLabel(d);
                });
            }
            
            // Update button text
            updateSelectAllButtonText();
            
            // Update the legend
            var selectedLeague = document.getElementById("select-league").value;
            updateLeagueLegend(selectedLeague);
        }
        

        
        // Initialize the chart
        updateChart();
        
        // Initialize the custom selectors now that data is loaded
        initializeCustomSelectors();
        
        // Function to update the league legend based on selected league
        function updateLeagueLegend(selectedLeague) {
            var legendContainer = document.getElementById('league-legend');
            
            // If only one league is selected (and it's not "all" or "Top 5 Leagues"), hide the legend completely
            if (selectedLeague !== "all" && selectedLeague !== "Top 5 Leagues") {
                legendContainer.style.display = 'none';
                return;
            }
            
            // Hide the legend if no teams are clicked
            if (clickedCircles.length === 0) {
                legendContainer.style.display = 'none';
                return;
            }
            
            // Otherwise, show the legend
            legendContainer.style.display = 'flex';
            legendContainer.innerHTML = ''; // Clear existing legend
            
            // Add a title for the legend
            var legendTitle = document.createElement('div');
            legendTitle.style.fontWeight = 'bold';
            legendTitle.style.marginRight = '15px';
            legendContainer.appendChild(legendTitle);
            
            // Determine which leagues to show in the legend
            var leaguesToShow = [];
            
            if (selectedLeague === "all") {
                // Show all leagues
                leaguesToShow = Object.keys(leagueColors);
            } else if (selectedLeague === "Top 5 Leagues") {
                // Show only Top 5 leagues
                leaguesToShow = ["Premier League", "La Liga", "Bundesliga", "Serie A", "Ligue 1"];
            }
            
            // Add an item for each relevant league
            leaguesToShow.forEach(function(league) {
                var legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                var colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = leagueColors[league];
                
                var leagueText = document.createElement('span');
                leagueText.textContent = league;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(leagueText);
                legendContainer.appendChild(legendItem);
            });
        }
        

        
        const data1 = dataLines.map(line => {
            const [name, link] = line.split(',');
            return { name, link };
        });
        
        function search2(query) {
            autocompleteBox.innerHTML = '';
            
            const normalizedQuery = query.toLowerCase();
            const matches = data1.filter(item => {
                const normalizedName = item.name ? item.name.toLowerCase() : '';
                return normalizedName.includes(normalizedQuery);
            });
            
            if (matches.length === 0) {
                autocompleteBox.style.display = 'none';
                return;
            }
            
            matches.forEach(match => {
                if (match.name && match.link) {
                    const div = document.createElement('div');
                    const a = document.createElement('a');
                    a.href = match.link;
                    a.textContent = match.name;
                    div.appendChild(a);
                    autocompleteBox.appendChild(div);
                }
            });
            
            autocompleteBox.style.display = 'block';
        }
        
        searchInput.addEventListener('input', () => {
            const query = searchInput.value;
            if (query.trim() === '') {
                autocompleteBox.style.display = 'none';
            } else {
                search2(query);
            }
        });
        
      
        // Function to add a team label
        function addTeamLabel(d) {
            var x = xScale(d[header.indexOf(xMetric)]);
            var y = yScale(d[header.indexOf(yMetric)]);
            
            // Create a unique class name for this team's label
            var teamClass = "team-label-" + d[1].replace(/\s+/g, '-').toLowerCase();
            
            // Check if this label already exists (avoid duplicates)
            if (svg.select("." + teamClass).size() > 0) {
                return;
            }
            
            // Create the label
            var label = svg.append("text")
                .attr("class", "team-label " + teamClass)
                .attr("x", x + 12)
                .attr("y", y + 4)
                .text(d[1])
                .style("font-family", "Inter, sans-serif")
                .style("font-size", "12px")
                .style("font-weight", "500")
                .style("fill", "#333")
                .attr("data-original-x", x)  // Store original position
                .attr("data-original-y", y)
                .attr("data-stable-position", "false"); // Track if we've found a stable position
                
            // Position the label to avoid overlaps and prevent overflow
            positionLabelToAvoidOverlap(label, x, y);
        }
        
        // Function to position a label to avoid overlaps with other labels
        function positionLabelToAvoidOverlap(label, x, y) {
            // If this label already has a stable position and we're just updating, 
            // use the existing position unless the data point has moved significantly
            if (label.attr("data-stable-position") === "true") {
                var originalX = parseFloat(label.attr("data-original-x"));
                var originalY = parseFloat(label.attr("data-original-y"));
                var currentX = parseFloat(label.attr("x"));
                var currentY = parseFloat(label.attr("y"));
                
                // Only reposition if the data point has moved significantly (more than 5 pixels)
                var distanceMoved = Math.sqrt(Math.pow(originalX - x, 2) + Math.pow(originalY - y, 2));
                if (distanceMoved < 5) {
                    // Update the original position but keep the current position
                    label.attr("data-original-x", x)
                         .attr("data-original-y", y);
                    return;
                }
                
                // Reset stability flag since we need to reposition
                label.attr("data-stable-position", "false");
            }
            
            // Get all existing labels except the current one
            var allLabels = svg.selectAll(".team-label").filter(function() {
                return this !== label.node();
            });
            
            // Get the bounding box of the new label
            var labelBox = label.node().getBBox();
            
            // Define possible positions to try (in order of preference)
            var positions = [
                { x: x + 12, y: y + 4 },           // Right (default)
                { x: x + 12, y: y - 10 },          // Top-right
                { x: x + 12, y: y + 18 },          // Bottom-right
                { x: x - labelBox.width - 5, y: y + 4 },  // Left
                { x: x - labelBox.width - 5, y: y - 10 }, // Top-left
                { x: x - labelBox.width - 5, y: y + 18 }, // Bottom-left
                { x: x - labelBox.width/2, y: y - 15 },   // Top
                { x: x - labelBox.width/2, y: y + 25 }    // Bottom
            ];
            
            // Try each position until we find one without overlaps
            var bestPosition = findPositionWithoutOverlap(positions, allLabels, labelBox);
            
            // Apply the best position
            label.attr("x", bestPosition.x)
                 .attr("y", bestPosition.y)
                 .attr("data-original-x", x)
                 .attr("data-original-y", y)
                 .attr("data-stable-position", "true"); // Mark this position as stable
        }
        
        // Function to find a position without overlap
        function findPositionWithoutOverlap(positions, existingLabels, labelBox) {
            // Try each position
            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                var hasOverlap = false;
                
                // Create a rectangle for this position
                var testRect = {
                    x1: pos.x,
                    y1: pos.y - labelBox.height,
                    x2: pos.x + labelBox.width,
                    y2: pos.y + 5
                };
                
                // Check if label would be outside chart bounds
                if (testRect.x1 < 0 || testRect.x2 > width || testRect.y1 < 0 || testRect.y2 > height) {
                    // This position would place the label outside the chart bounds
                    continue;
                }
                
                // Check for overlaps with existing labels
                existingLabels.each(function() {
                    var existingBox = d3.select(this).node().getBBox();
                    var existingX = parseFloat(d3.select(this).attr("x"));
                    var existingY = parseFloat(d3.select(this).attr("y"));
                    
                    var existingRect = {
                        x1: existingX,
                        y1: existingY - existingBox.height,
                        x2: existingX + existingBox.width,
                        y2: existingY + 5
                    };
                    
                    // Check if rectangles overlap
                    if (!(testRect.x2 < existingRect.x1 || 
                          testRect.x1 > existingRect.x2 || 
                          testRect.y2 < existingRect.y1 || 
                          testRect.y1 > existingRect.y2)) {
                        hasOverlap = true;
                    }
                });
                
                // If no overlap, use this position
                if (!hasOverlap) {
                    return pos;
                }
            }
            
            // If all positions have overlaps or are out of bounds, find a position that's at least within bounds
            for (var i = 0; i < positions.length; i++) {
                var pos = positions[i];
                
                // Create a rectangle for this position
                var testRect = {
                    x1: pos.x,
                    y1: pos.y - labelBox.height,
                    x2: pos.x + labelBox.width,
                    y2: pos.y + 5
                };
                
                // Check if label would be inside chart bounds
                if (testRect.x1 >= 0 && testRect.x2 <= width && testRect.y1 >= 0 && testRect.y2 <= height) {
                    // This position would place the label inside the chart bounds
                    return pos;
                }
            }
            
            // If all positions are problematic, create a position that's guaranteed to be within bounds
            var safePos = {
                x: Math.min(Math.max(0, positions[0].x), width - labelBox.width),
                y: Math.min(Math.max(labelBox.height, positions[0].y), height)
            };
            
            return safePos;
        }
        
        // Modify updateChart to reposition labels when the chart changes
        var originalUpdateChart = updateChart;
        updateChart = function() {
            // Call the original updateChart function
            originalUpdateChart();
            setTimeout(function() {
                var allLabels = svg.selectAll(".team-label");
                
                // Process labels one by one
                allLabels.each(function() {
                    var label = d3.select(this);
                    var teamName = label.text();
                    
                    // Find the team data
                    var teamData = filteredData.find(function(d) {
                        return d[1] === teamName;
                    });
                    
                    if (teamData) {
                        var x = xScale(teamData[header.indexOf(xMetric)]);
                        var y = yScale(teamData[header.indexOf(yMetric)]);
                        
                        // Reposition this label only if needed
                        positionLabelToAvoidOverlap(label, x, y);
                    }
                });
            }, 10); // Longer delay to ensure DOM is fully updated
        };


        // Initialize median lines tooltip text on page load
        document.addEventListener('DOMContentLoaded', function() {
            const medianTooltip = document.getElementById('median-lines-tooltip');
            medianTooltip.textContent = medianLinesVisible ? "Hide median lines" : "Show median lines";
        });
    </script>
  <script>



        // Global translation helper function
        function getTranslation(key, defaultText) {
            // Split the key into parts (e.g., "tooltip.xg-line-title" -> ["tooltip", "xg-line-title"])
            const keys = key.split('.');
            
            // Try to find the translation in the current language
            try {
                let currentTranslations = window.currentTranslations || {};
                for (const k of keys) {
                    if (currentTranslations && currentTranslations[k]) {
                        currentTranslations = currentTranslations[k];
                    } else {
                        return defaultText;
                    }
                }
                return currentTranslations;
            } catch (e) {
                return defaultText;
            }
        }
        
    
  function setLanguage(language) {
    localStorage.setItem('preferredLanguage', language);
    const url = new URL(window.location.href);
    if (language === 'en') {
      url.searchParams.delete('lang');
    } else {
      url.searchParams.set('lang', language);
    }
    window.history.pushState({}, '', url);
    applyLanguage(language);
  }
  
  function getPreferredLanguage() {
    // PRIORITY 1: Check URL parameter first
    const urlParams = new URLSearchParams(window.location.search);
    const langParam = urlParams.get('lang');
    if (langParam) {
      return langParam;
    }
    // PRIORITY 2: Check localStorage
    const storedLang = localStorage.getItem('preferredLanguage');
    if (storedLang) {
      return storedLang;
    }
    // PRIORITY 3: Use browser language
    return getBrowserLanguage() || 'en';
  }

  function getBrowserLanguage() {
    return navigator.language.slice(0, 2);
  }

  function applyLanguage(language) {
    console.log(language);

    if (language === 'en') {
      return;
    }

    
    fetch(`locales/${language}.json`)
      .then(response => {
        // Don't throw an error, just return null if response is not OK
        return response.ok ? response.json() : null;
      })
      .then(translations => {
        // Only proceed if translations exist
        if (translations) {
            window.currentTranslations = translations;
          document.querySelectorAll('[data-i18n]').forEach(element => {
            const keys = element.getAttribute('data-i18n').split('.');
            let value = translations;
            for (const key of keys) {
              if (value === undefined || value === null) break;
              value = value[key];
            }
            if (value) {
              if (element.tagName === 'META') {
              element.setAttribute('content', value);
          } else if (element.tagName === 'INPUT') {
              element.setAttribute('placeholder', value);
          } else if (value.includes('<')) {
              element.innerHTML = value;
          } else {
              element.textContent = value;
          }          }
          });
          // REMOVE FOR PAGES WITH NO METADATA
          document.querySelector('meta[name="language"]').setAttribute('content', language);
        }
      })
      .catch(() => {
        // Completely empty catch block to silently ignore any errors
      });
  }
  
  const preferredLanguage = getPreferredLanguage();
  applyLanguage(preferredLanguage);
  
  // BUTTON LANGUAGE SWITCHER REMOVE FOR PAGES WITH NO LANGUAGE SWITCHER
  document.addEventListener('DOMContentLoaded', function() {
    const languageButton = document.getElementById('languageButton');
    const languageDropdown = document.getElementById('languageDropdown');
    

    if (languageButton) {
      languageButton.addEventListener('click', function(e) {
        e.stopPropagation();
        languageDropdown.classList.toggle('show');
      });
    }
  
    document.querySelectorAll('.language-option').forEach(option => {
      option.addEventListener('click', function(e) {
        e.preventDefault();
        const lang = this.getAttribute('href').split('=')[1];
        setLanguage(lang);
        languageDropdown.classList.remove('show');
      });
    });
  
    document.addEventListener('click', function(event) {
      if (!event.target.closest('.language-switcher-container')) {
        if (languageDropdown) {
          languageDropdown.classList.remove('show');
        }
      }
    });
  });


function toggleDarkMode() {
            const body = document.querySelector("body");
            body.classList.toggle("dark-mode");
            
            // Store the user's preference in local storage
            const isDarkMode = body.classList.contains("dark-mode");
            localStorage.setItem("darkMode", isDarkMode);
            
            // Update chart to apply dark mode styles to SVG elements
        }
        
        // Check if user has a stored preference for dark mode
        document.addEventListener('DOMContentLoaded', function() {
            const storedDarkMode = localStorage.getItem("darkMode");
            
            if (storedDarkMode === "true") {
                const body = document.querySelector("body");
                body.classList.add("dark-mode");
            }
            
 
        });
        
        function takeScreenshot() {
            const chartContainer = document.querySelector('.chart-container');
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            html2canvas(chartContainer, {
                scale: 2, // Higher quality
                backgroundColor: isDarkMode ? '#2c2c2c' : '#FFFFFF',
                allowTaint: true,
                useCORS: true,
                logging: false
            }).then(function(renderedCanvas) {
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = renderedCanvas.width;
                finalCanvas.height = renderedCanvas.height;
                const finalCtx = finalCanvas.getContext('2d');
                finalCtx.drawImage(renderedCanvas, 0, 0);
                
                // Load the watermark
                const watermarkImg = new Image();
                watermarkImg.crossOrigin = "Anonymous";
                
                watermarkImg.onload = function() {
                    const watermarkWidth = finalCanvas.width * 0.3;
                    const watermarkHeight = (watermarkWidth / watermarkImg.width) * watermarkImg.height;
                    
                    const x = (finalCanvas.width - watermarkWidth) / 2;
                    const y = (finalCanvas.height - watermarkHeight) / 2;
                    
                    finalCtx.save();
                    finalCtx.globalAlpha = 0.04;
                    finalCtx.drawImage(watermarkImg, x, y, watermarkWidth, watermarkHeight);
                    finalCtx.restore();
                    
                    const dataURL = finalCanvas.toDataURL('image/png', 1.0);
                    const link = document.createElement('a');
                    link.download = 'DataMB Screenshot.png';
                    link.href = dataURL;
                    link.click();
                };
                watermarkImg.src = 'https://datamb.football/logo.png';
            }).catch(function(error) {
            });
        }
        
    </script>
         <center>
            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7677714701428206"
                 crossorigin="anonymous"></script>
            <!-- radarplotsearch -->
            <ins class="adsbygoogle"
                 style="display:block"
                 data-ad-client="ca-pub-7677714701428206"
                 data-ad-slot="6673239737"
                 data-ad-format="auto"
                 data-full-width-responsive="true"></ins>
            <script>
                 (adsbygoogle = window.adsbygoogle || []).push({});
            </script></center>
</body>
</html>
