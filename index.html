<!DOCTYPE html>
<html>
<head>	

    <meta name="viewport" content="user-scalable=no">
	<meta name="robots" content="noindex">


<link rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">


<defs>
<style>

.hidden {
            display: none;
        }
body {
    background-color: white;
    
  }

button {
Height: 30px;
}

.button-6 {
  position: relative;
  top: -20px;
  left: 20px;
  width: 20%;
  touch-action: manipulation;
  cursor: pointer;
}



/* Add custom CSS to style the layout */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

.container {
  display: flex;
  flex-wrap: wrap; /* Enable wrapping of flex items */
}

.inputs {
  flex: 0 0 20%;
  padding: 20px;
  flex-direction: column; /* Stack the inputs vertically */
font-size: 12px;
}

.inputs input {
  margin-bottom: 5px;
}

   

form {
  display: flex;
  flex-direction: column;
}

label {
  margin-bottom: 5px;
}

button {
  margin-top: 5px;
}


#tableWrapper {
  width: 70%;
  position: absolute;
  top: 35px;
  right: 2.5%;
  max-height: 645px; /* Set the desired fixed height */
  overflow: auto;
}




table {
  border-collapse: collapse;
 
}


/* Apply styles to header cells and data cells */
th, td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: left;
}


td {
  font-size: 13px;
}



/* Set the desired fixed width for the rest of the data cells */
td:not(:first-child) {
text-align: center;
  user-select: none; /* Prevent text selection in table cells */

}

/* Set the desired fixed width for the header cells (including the first column) */
th {
  background-color: #f2f2f2;
  font-size: 10px; /* Set the desired font size for header cells */
text-align: center;
  position: relative; /* Add this for positioning the arrows */

}


th:not(:first-child) {
  width: 10%;
}




th:not(:first-child)::after {
  content: "";
  display: block;
  position: absolute;
  top: 55%; /* Adjust this value to position the arrow vertically inside the cell */
  left: 0%; /* Adjust this value to position the arrow horizontally inside the cell */
  width: 0;
  height: 0;
  border-left: 3px solid transparent;
  border-right: 3px solid transparent;
  border-top: 6px solid black;
  transform: translateX(-50%);
}

th:not(:first-child)::before {
  content: "";
  display: block;
  position: absolute;
  bottom: 55%; /* Adjust this value to position the arrow vertically inside the cell */
  left: 0%; /* Adjust this value to position the arrow horizontally inside the cell */
  width: 0;
  height: 0;
  border-left: 3px solid transparent;
  border-right: 3px solid transparent;
  border-bottom: 6px solid black;
  transform: translateX(-50%);
}


  /* Dark Mode Styles */
  body.dark-mode,
  body.dark-mode * {
    color: #f2f2f2;
  }

  body.dark-mode {
    background-color: #0F0F0E;
  }

body.dark-mode .tooltip {
  color: #000000; /* Set the font color to black in dark mode */
  background-color: #f9f9f9;
  border: solid;
  border-width: 1px;
  border-radius: 5px;
  padding: 10px;
  font-size: 12px;
}




body.dark-mode th {
  color: #000000; /* Set the text color to a light color in dark mode */
}

body.dark-mode select {
  color: #f2f2f2; /* Set the text color to a light color in dark mode */
  background-color: #333333; /* Set the background color to a dark color in dark mode */
}

body.dark-mode input {
  color: #f2f2f2; /* Set the text color to a light color in dark mode */
  background-color: #333333; /* Set the background color to a dark color in dark mode */
}

 .dark-mode-toggle {
    position: relative;
    left: 10%;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 35px;
    height: 35px;
    background-color: #e0e0de;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
    margin-bottom: 15px;
  }

  @media (max-width: 767px) {
	  

  .dark-mode-toggle {
    left: 11.1%;
  }
  #tableWrapper {
  max-height: 950px; /* Set the desired fixed height */
  width: 72.8%;
}
.inputs {
  width: 10px;
 
}

}

.dark-mode-toggle .toggle-icon::before {
  font-family: "Ionicons";
  content: "\f467"; /* Unicode value for the moon icon in Ionicons */
  font-size: 32px; /* Adjust the value as needed */
}

body.dark-mode .dark-mode-toggle {
  background-color: #333333;
}



body.dark-mode .dark-mode-toggle .toggle-icon::before {
  font-family: "Ionicons";
  content: "\f3b0"; /* Unicode value for the sun icon in Ionicons */
  font-size: 21px; /* Adjust the value as needed */
}

body.dark-mode button {
  color: #f2f2f2; /* Set the text color to a light color in dark mode */
  background-color: #333333; /* Set the background color to a dark color in dark mode */
}

.player-info {
  font-style: italic;
  font-size: 11.3px; /* Adjust the font size as desired */
}

.no-results-message {
  margin: 21px; /* Adjust the margin as desired */
color: red;
}




 body.dark-mode {
    background-color: #0F0F0E;
  }

  select {
    
    padding: 4px 6px;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 5px;
    margin-bottom: 8px;
}


input {
    
    padding: 4px 6px;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 5px;
}

	

#SFctr {
	font-size: 15px !important;
}

#SFctr .SFfrm {
    margin-top: 20px;
margin-left: 10px;
}
	    
#SFctr td {
	font-family: Arial, Helvetica, sans-serif !important;
}

body.dark-mode #SFctr td {
	color: #f3f6f4 !important;
}
	    
#SFctr input[type="text"],
#SFctr input[type="password"],
#SFctr input[type="email"] {
	border-radius: 8px;

}
</style>



<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.16.9/xlsx.full.min.js"></script>

	
</head>

<body>

    <script type="text/javascript">document.body.style.visibility="hidden";</script><div id="SFctr" data-org="31002" data-mfl="64c215764c0b6076026762a3"><div style="clear:both"></div></div><script type="text/javascript" src="https://cdn.membershipworks.com/mfl.js"></script>

<div class="container">
  <div class="inputs">
  <form id="searchForm">
    <select id="datasetSelector">
      <option value="dataset1" data-i18n="position.goalkeepers">Goalkeepers</option>
      <option value="dataset2" data-i18n="position.centre-backs">Centre-backs</option>
      <option value="dataset3" data-i18n="position.full-backs">Full-backs</option>
      <option value="dataset4" data-i18n="position.midfielders">Midfielders</option>
      <option value="dataset5" data-i18n="position.wingers">Wingers</option>
      <option value="dataset6" data-i18n="position.strikers">Strikers</option>
      <!-- Add more options for additional datasets if needed -->
    </select>

    <select id="league">
      <option value="All" data-i18n="league.all">ğŸŒ All Leagues</option>
	    <option value="Top 5 Leagues" data-i18n="league.top5">ğŸ‡ªğŸ‡º Top 5 Leagues</option>
<option value="Top 7 Leagues" data-i18n="league.top7">ğŸ‡ªğŸ‡º Top 7 Leagues</option>
      <option value="Premier League">ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ Premier League</option>
<option value="La Liga">ğŸ‡ªğŸ‡¸ La Liga</option>
<option value="Bundesliga">ğŸ‡©ğŸ‡ª Bundesliga</option>
<option value="Serie A">ğŸ‡®ğŸ‡¹ Serie A</option> 
<option value="Ligue 1">ğŸ‡«ğŸ‡· Ligue 1</option>
<option value="Liga Portugal">ğŸ‡µğŸ‡¹ Liga Portugal</option>
<option value="Eredivisie">ğŸ‡³ğŸ‡± Eredivisie</option>
<option value="Belgium Pro League">ğŸ‡§ğŸ‡ª Belgium</option>
<option value="Scotland Premiership">ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ Scotland</option>
<option value="Austrian Bundesliga">ğŸ‡¦ğŸ‡¹ Austria</option>
<option value="Swiss Super League">ğŸ‡¨ğŸ‡­ Switzerland</option>      
<option value="SÃ¼per Lig">ğŸ‡¹ğŸ‡· TÃ¼rkiye</option>
<option value="Denmark Superliga">ğŸ‡©ğŸ‡° Denmark</option>
<option value="Sweden Allsvenskan">ğŸ‡¸ğŸ‡ª Sweden</option>
<option value="Norway Eliteserien">ğŸ‡³ğŸ‡´ Norway</option>
<option value="Croatia HNL">ğŸ‡­ğŸ‡· Croatia</option>
<option value="Serbia SuperLiga">ğŸ‡·ğŸ‡¸ Serbia</option>
<option value="Czech Fortuna Liga">ğŸ‡¨ğŸ‡¿ Czech Republic</option>
<option value="Poland">ğŸ‡µğŸ‡± Poland</option>
<option value="Ukraine">ğŸ‡ºğŸ‡¦ Ukraine</option>
<option value="Russia">ğŸ‡·ğŸ‡º Russia</option>
<option value="Greece">ğŸ‡¬ğŸ‡· Greece</option>
<option value="Israel">ğŸ‡®ğŸ‡± Israel</option>
<option value="J1 League">ğŸ‡¯ğŸ‡µ Japan</option>
<option value="K League 1">ğŸ‡°ğŸ‡· Korea</option>
<option value="Saudi Pro League">ğŸ‡¸ğŸ‡¦ Saudi Arabia</option>
<option value="MLS">ğŸ‡ºğŸ‡¸ United States</option>
<option value="LigaMX">ğŸ‡²ğŸ‡½ Mexico</option>
<option value="Brazil Serie A">ğŸ‡§ğŸ‡· Brazil</option>
<option value="Argentina Primera">ğŸ‡¦ğŸ‡· Argentina</option>
<option value="Uruguay Primera">ğŸ‡ºğŸ‡¾ Uruguay</option>
<option value="Chile">ğŸ‡¨ğŸ‡± Chile</option>
<option value="Colombia">ğŸ‡¨ğŸ‡´ Colombia</option>
<option value="Ecuador">ğŸ‡ªğŸ‡¨ Ecuador</option>
<option value="Paraguay">ğŸ‡µğŸ‡¾ Paraguay</option>
<option value="Championship">ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ Championship</option>
<option value="Segunda Division">ğŸ‡ªğŸ‡¸ Spain Segunda</option>
<option value="Serie B">ğŸ‡®ğŸ‡¹ Serie B</option>
<option value="Bundesliga 2">ğŸ‡©ğŸ‡ª 2. Bundesliga</option>
<option value="Ligue 2">ğŸ‡«ğŸ‡· Ligue 2</option>  
<option value="Non Top 7 Leagues">ğŸŒ Outside Top 7</option>
<option value="South America">ğŸŒ South America</option>
<option value="Scandinavia">ğŸŒ Scandinavia</option>
<option value="Balkans">ğŸŒ Eastern Europe</option>
    
    </select>

    <label for="defensiveActions" data-i18n="metrics.gk.def_actions">Def actions</label>
    <input type="number" id="defensiveActionsLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="aerialsContested" data-i18n="metrics.gk.aerials">Aerials</label>
    <input type="number" id="aerialsContestedLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="exitLine" data-i18n="metrics.gk.exit_line">Exit line</label>
    <input type="number" id="exitLineLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="passes" data-i18n="metrics.gk.passes">Passes</label>
    <input type="number" id="passesLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="longPassPercentage" data-i18n="metrics.gk.long_pass">Long pass%</label>
    <input type="number" id="longPassPercentageLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="shortPassPercentage" data-i18n="metrics.gk.short_pass">Short pass%</label>
    <input type="number" id="shortPassPercentageLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

    <label for="psxg" data-i18n="metrics.gk.psxg_ga">PSxG - GA</label>
    <input type="number" id="psxgLow" min="0" max="100" data-i18n-placeholder="search.percentile" placeholder="Percentile 0-100">

 
    <label for="ageLow" data-i18n="search.age">Age</label>
    <input type="number" id="ageLow" min="0" placeholder="15">
    <label for="ageHigh"></label>
    <input type="number" id="ageHigh" min="0" placeholder="45">

    <label for="minutesPlayedLow" data-i18n="search.minutes">Minutes Played</label>
    <input type="number" id="minutesPlayedLow" min="0" placeholder="0">
    <label for="minutesPlayedHigh"></label>
    <input type="number" id="minutesPlayedHigh" min="0" placeholder="10,000">

    <button type="submit" data-i18n="search.button">Search</button>
  </form>
  </div>
</div>
  <div id="resultsContainer">
    <!-- The search results will be displayed here -->
  </div> 
<div id="tableWrapper">
  <script>

const leagues = {


   
    "Ecuador": [
      "Universidad", "TÃ©cnico Universitario", "Orense", "Mushuc Runa", 
      "MacarÃ¡", "Libertad (ECU)", "LDU Quito", "Independiente del Valle", 
      "Imbabura", "Emelec", "El Nacional", "Deportivo Cuenca", 
      "Delfin", "CumbayÃ¡", "Barcelona (ECU)", "Aucas", "Guayaquil City", "Gualaceo",
   ],

   "Chile": [
      "Ã‘ublense", "UniÃ³n La Calera", "UniÃ³n EspaÃ±ola", "Universidad de Chile", 
      "Universidad CatÃ³lica", "Palestino", "O'Higgins", "Huachipato", 
      "Everton (CHI)", "Deportes Iquique", "Coquimbo Unido", "CopiapÃ³", 
      "Colo Colo", "Cobresal", "Cobreloa", "Audax Italiano", "CuricÃ³ Unido", "Magallanes",
   ],

    
      
   "Paraguay": [
      "Tacuary", "Sportivo Trinidense", "Sportivo LuqueÃ±o", "Sportivo Ameliano", 
      "Sol de AmÃ©rica", "Olimpia", "Nacional AsunciÃ³n", "Libertad", 
      "GuaranÃ­", "General Caballero JLM", "Cerro PorteÃ±o", "2 de Mayo", "Resistencia", "GuaireÃ±a",
   ],

   "Colombia": [
      "Ãguilas Doradas", "Tolima", "Santa Fe", "MedellÃ­n", 
      "Patriotas BoyacÃ¡", "Once Caldas", "Millonarios", "La Equidad", 
      "Junior", "Jaguares de CÃ³rdoba", "Fortaleza (COL)", "Envigado", 
      "Deportivo Pereira", "Deportivo Pasto", "Deportivo Cali", "BoyacÃ¡ ChicÃ³", 
      "AtlÃ©tico Nacional", "AtlÃ©tico Bucaramanga", "AmÃ©rica de Cali", "Alianza", "AtlÃ©tico Huila", "UniÃ³n Magdalena",
   ],

   
"Argentina Primera": [
"Argentinos Juniors", "AtlÃ©tico TucumÃ¡n", "Banfield", "Barracas Central", "Belgrano",
"Boca Juniors", "Central CÃ³rdoba SdE", "Defensa y Justicia", "Deportivo Riestra", "Estudiantes",
"Gimnasia La Plata", "Godoy Cruz", "HuracÃ¡n", "Independiente", "Independiente Rivadavia",
"Instituto", "LanÃºs", "Newell's Old Boys", "Platense", "Racing Club",
"River Plate", "Rosario Central", "San Lorenzo", "Sarmiento", "Talleres CÃ³rdoba",
"Tigre", "UniÃ³n Santa Fe", "VÃ©lez Sarsfield", "ColÃ³n",
],



"Brazil Serie A": [
"Athletico Paranaense", "AtlÃ©tico GO", "AtlÃ©tico Mineiro", "Bahia", "Botafogo",
"Corinthians", "CriciÃºma", "Cruzeiro", "CuiabÃ¡", "Flamengo",
"Fluminense", "Fortaleza", "GrÃªmio", "Internacional", "Juventude",
"Palmeiras", "Red Bull Bragantino", "SÃ£o Paulo", "Vasco da Gama", "VitÃ³ria", "Santos", "AmÃ©rica Mineiro", "Coritiba", "GoiÃ¡s",
],


"Uruguay Primera": [
"Boston River", "Cerro", "Cerro Largo", "Danubio", "Defensor Sporting",
"Deportivo Maldonado", "FÃ©nix", "Liverpool (URU)", "Miramar Misiones", "Nacional (URU)",
"PeÃ±arol", "Progreso", "Racing", "Rampla Juniors", "River Plate (URU)", "Wanderers", "Plaza Colonia", "La Luz", "Torque",
],

"MLS": [
"Los Angeles FC", "Philadelphia Union", "SJ Earthquakes", "Orlando City", "Toronto",
"Minnesota United", "Colorado Rapids", "Chicago Fire", "St. Louis City", "St. Louis City ", "Charlotte FC",
"Dallas", "Vancouver Whitecaps", "Inter Miami", "Austin FC", "DC United",
"Los Angeles Galaxy", "New York RB", "Sporting KC", "Portland Timbers", "Nashville SC",
"Seattle Sounders", "CF MontrÃ©al", "Real Salt Lake", "New York City", "Houston Dynamo",
"Atlanta United", "New England", "Cincinnati", "Columbus Crew",
],

"K League 1": [
"Gangwon", "Seoul", "Pohang Steelers", "Suwon", "Gwangju",
"Jeju United", "Ulsan Hyundai", "Daejeon Citizen", "Jeonbuk Motors",
"Incheon United", "Daegu", "Gimcheon Sangmu",
],

          

"J1 League": [
"Albirex Niigata", "Avispa Fukuoka", "Cerezo Osaka", "Consadole Sapporo", "Gamba Osaka",
"JÃºbilo Iwata", "Kashima Antlers", "Kashiwa Reysol", "Kawasaki Frontale", "Kyoto Sanga",
"Machida Zelvia", "Nagoya Grampus", "Sagan Tosu", "Sanfrecce Hiroshima", "Shonan Bellmare",
"Tokyo", "Tokyo Verdy", "Urawa Reds", "Vissel Kobe", "Yokohama F. Marinos", "Suwon Bluewings", "Yokohama",
],


"Norway Eliteserien": [
"BodÃ¸ / Glimt", "Brann", "Fredrikstad", "HamKam", "Haugesund",
"KFUM", "Kristiansund", "LillestrÃ¸m", "Molde", "Odds",
"Rosenborg", "Sandefjord", "Sarpsborg 08", "StrÃ¸msgodset", "TromsÃ¸",
"Viking", "VÃ¥lerenga", "Aalesund", "StabÃ¦k",
],


"Sweden Allsvenskan": [
"AIK", "Brommapojkarna", "DjurgÃ¥rden", "Elfsborg", "GAIS",
"Halmstad", "Hammarby", "HÃ¤cken", "IFK GÃ¶teborg", "IFK NorrkÃ¶ping",
"Kalmar", "MalmÃ¶ FF", "MjÃ¤llby", "Sirius", "VÃ¤rnamo",
"VÃ¤sterÃ¥s SK","Degerfors", "Varbergs",

],

"Ukraine": [
"Shakhtar Donetsk", "Dynamo Kyiv", "Polissya", "Vorskla", "Rukh Lviv", "Kryvbas KR", "Zorya", "Veres", "Obolon", "Livyi Bereh", "LNZ Cherkasy", "Inhulets", "Karpaty", "Oleksandria", "Chornomorets", "Kolos Kovalivka", 
   ],

   "Poland": [
"Cracovia KrakÃ³w", "PogoÅ„ Szczecin", "Lech PoznaÅ„", "Korona Kielce", "Legia Warszawa", "ÅšlÄ…sk WrocÅ‚aw", "ZagÅ‚Ä™bie Lubin", "Jagiellonia BiaÅ‚ystok", "Widzew ÅÃ³dÅº", "RakÃ³w CzÄ™stochowa", "Piast Gliwice", "Puszcza NiepoÅ‚omice", "Stal Mielec", "Lechia GdaÅ„sk", "Katowice", "Motor Lublin", "GÃ³rnik Zabrze", "Radomiak Radom", 
   ],

   "Russia": [
"Lokomotiv Moskva", "Spartak Moskva", "Krylya Sovetov", "CSKA Moskva", "Zenit", "Krasnodar", "Orenburg", "Rubin Kazan'", "Dinamo Moskva", "Akhmat Grozny", "Nizhny Novgorod", "Fakel", "Akron Togliatti", "Dynamo Makhachkala", "Khimki", "Rostov", "Ural", "Baltika", "Sochi", 
   ],

   "Israel": [
"Hapoel Haifa", "Maccabi Petah Tikva", "Ironi Kiryat Shmona", "Beitar Jerusalem", "Hapoel Jerusalem", "Maccabi Tel Aviv", "Maccabi Bnei Raina", "Ashdod", "Maccabi Netanya", "Ironi Tiberias", "Hapoel Hadera", "Bnei Sakhnin", "Hapoel Be'er Sheva", "Maccabi Haifa", 
   ],

   "Greece": [
"PAOK", "Panathinaikos", "Olympiacos Piraeus", "AEK Athens", "Panetolikos FC", "OFI", "Atromitos", "Aris", "Volos NFC", "Asteras Tripolis", "Panserraikos", "Lamia", "Levadiakos", "Athens Kallithea", "Ergotelis", "PAE Chania", "Diagoras Rodou", "AO Xanthi", "Ionikos", "Trikala", "Panachaiki", "Doxa Dramas", "Apollon Larisas", "Karaiskakis Artas", "Ierapetras",
   ],

"Championship": [
"Burnley", "Leeds United", "Sunderland", "Preston North End", "Luton Town", "Stoke City", "Derby County", "Bristol City", "Coventry City", "Norwich City", "Queens Park Rangers", "Watford", "Middlesbrough", "Hull City", "Cardiff City", "West Bromwich Albion", "Blackburn Rovers", "Sheffield United", "Oxford United", "Plymouth Argyle", "Millwall", "Portsmouth", "Swansea City", "Sheffield Wednesday", 
],
"SÃ¼per Lig": [
"FenerbahÃ§e", "Trabzonspor", "Kayserispor", "Ä°stanbul BaÅŸakÅŸehir", "Rizespor", "GÃ¶ztepe", "EyÃ¼pspor", "Galatasaray", "BeÅŸiktaÅŸ", "Bodrumspor", "Samsunspor", "Antalyaspor", "Konyaspor", "KasÄ±mpaÅŸa", "Gaziantep", "Hatayspor", "Sivasspor", "Alanyaspor", "Adana Demirspor",
],

"Segunda Division": [
"AlmerÃ­a", "Granada", "Sporting GijÃ³n", "Racing Santander", "CÃ¡diz", "Elche", "Real Oviedo", "Deportivo La CoruÃ±a", "Burgos", "Cartagena", "Eldense", "Real Zaragoza", "Eibar", "CastellÃ³n", "Racing Ferrol", "MÃ¡laga", "Levante", "CÃ³rdoba", "Huesca", "Tenerife", "Albacete", "MirandÃ©s",
],

"Scotland Premiership": [
"Rangers", "Celtic", "Hibernian", "Hearts", "Aberdeen", "Kilmarnock", "Dundee United", "Ross County", "St. Mirren", "Dundee", "St. Johnstone", "Motherwell", 
],

"Belgium Pro League": [
"Cercle Brugge", "OH Leuven", "Union Saint-Gilloise", "Club Brugge", "Genk", "Gent", "Antwerp", "Kortrijk", "Beerschot-Wilrijk", "Standard LiÃ¨ge", "Sint-Truiden", "Dender", "Westerlo", "Mechelen", "Anderlecht", "Charleroi", 
],

"Swiss Super League": [
"Lugano", "Young Boys", "Yverdon Sport", "St. Gallen", "Grasshopper", "Lausanne Sport", "Sion", "ZÃ¼rich", "Servette", "Winterthur", "Basel", "Luzern",
],

"Austrian Bundesliga": [
"Sturm Graz", "LASK", "Salzburg", "Rapid Wien", "Hartberg", "Wolfsberger AC", "Rheindorf Altach", "WSG Swarovski Tirol", "Austria Wien", "Grazer AK", "Blau-WeiÃŸ Linz", "Austria Klagenfurt", 
],

"Saudi Pro League": [
"Al Nassr", "Al Ittihad", "Al Hilal", "Al Ahli", "Al Qadisiyah", "Al Taawon", "Al Ettifaq", "Al Orubah", "Al Wehda", "Al Khaleej", "Al Shabab", "Al Fateh", "Al Kholood", "Al Riyadh", "Al Akhdoud", "Dhamk", "Al Raed", "Al Feiha", 
],

"LigaMX": [
"AmÃ©rica", "Cruz Azul", "Santos Laguna", "Necaxa", "Pachuca", "Guadalajara", "Monterrey", "Toluca", "Atlas", "Club Tijuana", "Puebla", "AtlÃ©tico de San Luis", "JuÃ¡rez", "Tigres UANL", "Pumas UNAM", "MazatlÃ¡n", "QuerÃ©taro", "LeÃ³n", 
],

"Denmark Superliga": [
"BrÃ¸ndby", "Viborg", "NordsjÃ¦lland", "KÃ¸benhavn", "Midtjylland", "SÃ¸nderjyskE", "AaB", "Silkeborg", "Randers", "Lyngby", "Vejle", "AGF",
],

"Czech Fortuna Liga": [
"Sparta Praha", "Viktoria PlzeÅˆ", "Hradec KrÃ¡lovÃ©", "Teplice", "BanÃ­k Ostrava", "MladÃ¡ Boleslav", "Slovan Liberec", "Pardubice", "Sigma Olomouc", "Dukla Praha", "ÄŒeskÃ© BudÄ›jovice", "SlovÃ¡cko", "KarvinÃ¡", "Bohemians 1905", "Jablonec", "Slavia Praha",
],

"Serbia SuperLiga": [
"BaÄka Topola", "Partizan", "Spartak Subotica", "RadniÄki NiÅ¡", "Crvena Zvezda", "Napredak KruÅ¡evac", "OFK Beograd", "Vojvodina", "Novi Pazar", "RadniÄki Kragujevac", "ÄŒukariÄki", "Tekstilac OdÅ¾aci", "Jedinstvo Ub", "Mladost LuÄani", "Å½elezniÄar Pancevo", "IMT Novi Beograd",
],

"Croatia HNL": [
"Hajduk Split", "Dinamo Zagreb", "Osijek", "Istra 1961", "Rijeka", "VaraÅ¾din", "Slaven Belupo", "Lokomotiva Zagreb", "Gorica", "Å ibenik", 
],

"Bundesliga 2": [
"KÃ¶ln", "Hertha BSC", "Fortuna DÃ¼sseldorf", "Kaiserslautern", "Darmstadt 98", "Magdeburg", "Hamburger SV", "Jahn Regensburg", "Paderborn", "Eintracht Braunschweig", "Greuther FÃ¼rth", "Hannover 96", "NÃ¼rnberg", "Karlsruher SC", "Schalke 04", "Ulm", "PreuÃŸen MÃ¼nster", "Elversberg", 
],

"Serie B": [
"Pisa", "Palermo", "Cittadella", "Bari", "Catanzaro", "Modena", "Cremonese", "Frosinone", "Carrarese", "Sampdoria", "Salernitana", "Cosenza", "Juve Stabia", "Brescia", "Cesena", "Mantova", "Sassuolo", "Spezia", "Reggiana", "SÃ¼dtirol",
],

"Ligue 2": [
"Lorient","Caen", "Paris", "Pau", "Guingamp", "Rodez", "Annecy", "Metz", "Red Star", "Dunkerque", "Grenoble", "Ajaccio", "Laval", "Amiens SC", "Troyes", "Bastia", "Martigues", "Clermont", "Rodez ",
],

"Liga Portugal": [
"Porto", "Benfica", "Sporting CP", "Sporting Braga", "VitÃ³ria GuimarÃ£es", "Gil Vicente", "Farense", "Moreirense", "Nacional", "Arouca", "Estoril", "Rio Ave", "Santa Clara", "Boavista", "Casa Pia AC", "FamalicÃ£o", "Estrela Amadora", "AVS", "AVS ",
],

"Ligue 1": [
"PSG", "Lille", "Nice", "Lens", "Nantes", "Reims", "Olympique Lyonnais", "Monaco", "Olympique Marseille", "Brest", "Saint-Ã‰tienne", "Montpellier", "Angers SCO", "Le Havre", "Rennes", "Auxerre", "Strasbourg", "Toulouse", 
],

"Premier League": [
"Manchester City", "Tottenham Hotspur", "Arsenal", "Manchester United", "Aston Villa", "Liverpool", "Southampton", "Everton", "Chelsea", "Brighton", "Newcastle United", "Wolverhampton Wanderers", "Fulham", "Crystal Palace", "Brentford", "Bournemouth", "West Ham United", "Leicester City", "Nottingham Forest", "Ipswich Town", "Wolverhampton",
],

"Bundesliga": [
"Borussia Dortmund", "Stuttgart", "Wolfsburg", "Bayer Leverkusen", "Borussia M'gladbach", "Augsburg", "Union Berlin", "Eintracht Frankfurt", "Bayern MÃ¼nchen", "Hoffenheim", "Mainz 05", "Werder Bremen", "RB Leipzig", "St. Pauli", "Holstein Kiel", "Freiburg", "Heidenheim", "Bochum", "Borussia Mgladbach",
],

"Eredivisie": [
"PSV", "Feyenoord", "Sparta Rotterdam", "Twente", "Utrecht", "Groningen", "PEC Zwolle", "Almere City", "NAC Breda", "NEC", "Fortuna Sittard", "Go Ahead Eagles", "Heerenveen", "Willem II", "Heracles", "AZ", "RKC Waalwijk", "Ajax",
],

"La Liga": [
"Valencia", "AtlÃ©tico Madrid", "Barcelona", "Real Madrid", "Real Sociedad", "Real Betis", "Osasuna", "Deportivo AlavÃ©s", "Getafe", "Athletic Bilbao", "Girona", "Mallorca", "Villarreal", "Real Valladolid", "Rayo Vallecano", "LeganÃ©s", "Sevilla", "Las Palmas", "Celta de Vigo", "Espanyol",
],

"Serie A": [
"Milan", "Juventus", "Atalanta", "Lazio", "Napoli", "Roma", "Monza", "Internazionale", "Lecce", "Torino", "Parma", "Udinese", "Genoa", "Hellas Verona", "Bologna", "Fiorentina", "Cagliari", "Venezia", "Como", "Empoli", 
],

};


const allData1 = [];
  const allData2 = [];
  const allData3 = [];
  const allData4 = [];
  const allData5 = [];
  const allData6 = [];
  const allData7 = [];
  const allData8 = [];
  const allData9 = [];
  const allData10 = [];
  const allData11 = [];
  const allData12 = [];
    let allDataAsString1 = '';
    let allDataAsString2 = '';
    let allDataAsString3 = '';
    let allDataAsString4 = '';
    let allDataAsString5 = '';
    let allDataAsString6 = '';


    const urls1 = [
    'https://datamb.football/database/CURRENT/RATOP72425/GK/GK.xlsx',
];

    const urls2 = [
    'https://datamb.football/database/CURRENT/RAPRO2425/GK/GK.xlsx',
'https://datamb.football/database/CURRENT/RAPRO2024/GK/GK.xlsx',

    ]

    const urls3 = [
    'https://datamb.football/database/CURRENT/RATOP72425/CB/CB.xlsx',
  ];

    const urls4 = [
  
    'https://datamb.football/database/CURRENT/RAPRO2425/CB/CB.xlsx',
'https://datamb.football/database/CURRENT/RAPRO2024/CB/CB.xlsx',


    ]

    const urls5 = [
    'https://datamb.football/database/CURRENT/RATOP72425/FB/FB.xlsx',

  
];

    const urls6 = [
    'https://datamb.football/database/CURRENT/RAPRO2425/FB/FB.xlsx',
'https://datamb.football/database/CURRENT/RAPRO2024/FB/FB.xlsx',


    ]
    

    const urls7 = [
    'https://datamb.football/database/CURRENT/RATOP72425/CM/CM.xlsx',
];

    const urls8 = [
    'https://datamb.football/database/CURRENT/RAPRO2425/CM/CM.xlsx',
    'https://datamb.football/database/CURRENT/RAPRO2024/CM/CM.xlsx',
    ]

    const urls9 = [
    'https://datamb.football/database/CURRENT/RATOP72425/FW/FW.xlsx',

];

    const urls10 = [
    'https://datamb.football/database/CURRENT/RAPRO2425/FW/FW.xlsx',
    'https://datamb.football/database/CURRENT/RAPRO2024/FW/FW.xlsx',


    ]

    const urls11 = [
    'https://datamb.football/database/CURRENT/RATOP72425/ST/ST.xlsx',

];

    const urls12 = [
   'https://datamb.football/database/CURRENT/RAPRO2425/ST/ST.xlsx',
    'https://datamb.football/database/CURRENT/RAPRO2024/ST/ST.xlsx',

    ]


    const fetchPromises1 = urls1.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises2 = urls2.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData1(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed
                row.splice(12, 0, row.splice(4, 1)[0]);
                row.splice(7, 0, row.splice(11, 1)[0]);
                row.splice(9, 0, row.splice(10, 1)[0]);
                row[15] = `${row[1]}`;
                row.splice(16, 1);
    
                // Reorder columns
                const reorderedRow = [
                    row[0],
                    row[15],
                    row[2],
                    row[4],
                    row[5],
                    row[11],
                    row[6],
                    row[10],
                    row[8],
                    row[9],
                    row[7],
                    row[3]
                ];
                allData1.push(reorderedRow);
            });
         

function getTeamLeague1(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData1.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague1(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData1.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData1.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData2(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed
                row.splice(12, 0, row.splice(4, 1)[0]);
                row.splice(7, 0, row.splice(11, 1)[0]);
                row.splice(9, 0, row.splice(10, 1)[0]);
                row[15] = `${row[1]}`;
                row.splice(16, 1);
    
                const reorderedRow = [
                    row[0],
                    row[15],
                    row[2],
                    row[4],
                    row[5],
                    row[11],
                    row[6],
                    row[10],
                    row[8],
                    row[9],
                    row[7],
                    row[3]
                ];
    
                allData2.push(reorderedRow);
            });
           

function getTeamLeague2(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData2.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague2(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData2.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData2.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises1)
        .then(responses => {
            processAndStoreData1(responses);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises2)
                .then(responses2 => {
                    processAndStoreData2(responses2);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData1.concat(allData2);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString1 += row.join(',') + '\n';
                    });
    
// Replace all '\n' characters with actual new rows in the CSV
let csvData1 = allDataAsString1.split('\\n').join('\n');

// Convert the CSV string into an array of rows
let rows = csvData1.split('\n');

// Remove the last row
rows.pop();

// Join the rows back into a single string
csvData1 = rows.join('\n');


const fetchPromises3 = urls3.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises4 = urls4.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData3(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed
                row.splice(12, 0, row.splice(4, 1)[0]);
                row.splice(7, 0, row.splice(11, 1)[0]);
                row.splice(9, 0, row.splice(10, 1)[0]);
                row[15] = `${row[1]}`;
                row[14] = (row[9] * row[10]) / 100;  // Equivalent formula
                row.splice(16, 1);
    
                // Reorder columns
                const reorderedRow = [
                    row[0],
                    row[15],
                    row[2],
                    row[14],
                    row[11],
                    row[7],
                    row[4],
                    row[5],
                    row[6],
                    row[8],
                    row[12],
                    row[3]
                ];
                allData3.push(reorderedRow);
            });
         

function getTeamLeague3(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData3.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague3(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData3.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData3.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData4(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed
                row.splice(12, 0, row.splice(4, 1)[0]);
                row.splice(7, 0, row.splice(11, 1)[0]);
                row.splice(9, 0, row.splice(10, 1)[0]);
                row[15] = `${row[1]}`;
                row[14] = (row[9] * row[10]) / 100;  // Equivalent formula
                row.splice(16, 1);
    
                // Reorder columns
                const reorderedRow = [
                    row[0],
                    row[15],
                    row[2],
                    row[14],
                    row[11],
                    row[7],
                    row[4],
                    row[5],
                    row[6],
                    row[8],
                    row[12],
                    row[3]
                ];
    
                allData4.push(reorderedRow);
            });
           

function getTeamLeague4(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData4.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague4(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData4.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData4.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises3)
        .then(responses3 => {
            processAndStoreData3(responses3);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises4)
                .then(responses4 => {
                    processAndStoreData4(responses4);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData3.concat(allData4);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString2 += row.join(',') + '\n';
                    });
    

                    let csvData2 = allDataAsString2.split('\\n').join('\n');
let rows2 = csvData2.split('\n');
rows2.pop();
csvData2 = rows2.join('\n');

const fetchPromises5 = urls5.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises6 = urls6.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData5(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
    
                // Reorder columns
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[8],
                row[10],
                row[11],
                row[5],
                row[6],
                row[7],
                row[9],
                row[4],
                row[3]
                ];
                allData5.push(reorderedRow);
            });
         

function getTeamLeague5(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData5.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague5(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData5.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData5.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData6(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[8],
                row[10],
                row[11],
                row[5],
                row[6],
                row[7],
                row[9],
                row[4],
                row[3]
                ];
    
                allData6.push(reorderedRow);
            });
           

function getTeamLeague6(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData6.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague6(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData6.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData6.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises5)
        .then(responses5 => {
            processAndStoreData5(responses5);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises6)
                .then(responses6 => {
                    processAndStoreData6(responses6);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData5.concat(allData6);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString3 += row.join(',') + '\n';
                    });
    

                    let csvData3 = allDataAsString3.split('\\n').join('\n');
let rows3 = csvData3.split('\n');
rows3.pop();
csvData3 = rows3.join('\n');


const fetchPromises7 = urls7.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises8 = urls8.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData7(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
    
                // Reorder columns
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[5],
              row[6],
              row[7],
              row[8],
              row[9],
              row[10],
              row[11],
              row[4],
                row[3]
                ];
                allData7.push(reorderedRow);
            });
         

function getTeamLeague7(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData7.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague7(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData7.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData7.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData8(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
    
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[5],
              row[6],
              row[7],
              row[8],
              row[9],
              row[10],
              row[11],
              row[4],
                row[3]
                ];
    
                allData8.push(reorderedRow);
            });
           

function getTeamLeague8(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData8.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague8(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData8.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData8.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises7)
        .then(responses7 => {
            processAndStoreData7(responses7);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises8)
                .then(responses8 => {
                    processAndStoreData8(responses8);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData7.concat(allData8);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString4 += row.join(',') + '\n';
                    });
    


                    let csvData4 = allDataAsString4.split('\\n').join('\n');
let rows4 = csvData4.split('\n');
rows4.pop();
csvData4 = rows4.join('\n');



const fetchPromises9 = urls9.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises10 = urls10.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData9(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
                row[14] = (row[9] * row[10]) / 100;  // Equivalent formula
              row[16] = (row[7] + row[12]);  // Equivalent formula


                // Reorder columns
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[11],
                  row[14],
                  row[6],
                  row[16],
                  row[8],
                  row[13],
                  row[5],
                  row[4],
                row[3]
                ];
                allData9.push(reorderedRow);
            });
         

function getTeamLeague9(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData9.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague9(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData9.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData9.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData10(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
                row[14] = (row[9] * row[10]) / 100;  // Equivalent formula
              row[16] = (row[7] + row[12]);  // Equivalent formula
    
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[11],
                  row[14],
                  row[6],
                  row[16],
                  row[8],
                  row[13],
                  row[5],
                  row[4],
                row[3]
                ];
    
                allData10.push(reorderedRow);
            });
           

function getTeamLeague10(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData10.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague10(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData10.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData10.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises9)
        .then(responses9 => {
            processAndStoreData9(responses9);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises10)
                .then(responses10 => {
                    processAndStoreData10(responses10);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData9.concat(allData10);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString5 += row.join(',') + '\n';
                    });
    

                    let csvData5 = allDataAsString5.split('\\n').join('\n');
let rows5 = csvData5.split('\n');
rows5.pop();
csvData5 = rows5.join('\n');

const fetchPromises11 = urls11.map(url => fetch(url).then(response => response.arrayBuffer()));
const fetchPromises12 = urls12.map(url => fetch(url).then(response => response.arrayBuffer()));

    function processAndStoreData11(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
    
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[9],
              row[5],
              row[7],
              row[8],
              row[11],
              row[10],
              row[6],
              row[4],
                row[3]
                ];
                allData11.push(reorderedRow);
            });
         

function getTeamLeague11(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData11.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague11(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData11.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData11.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

    function processAndStoreData12(dataArray) {
        // Unique ID counter
        let uniqueIdCounter = 1;
    
        dataArray.forEach(data => {
            const workbook = XLSX.read(new Uint8Array(data), { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
    
            // Exclude header row
            const dataWithoutHeader = jsonData.slice(1);
    
            // Perform transformations and add unique ID
            dataWithoutHeader.forEach(row => {
                // Generate unique ID and shift columns
                row.unshift(`${uniqueIdCounter++}`);
    
                // Shift columns as needed

                row[15] = `${row[1]}`;
    
                const reorderedRow = [
                row[0],
                row[15],
                row[2],
                row[9],
              row[5],
              row[7],
              row[8],
              row[11],
              row[10],
              row[6],
              row[4],
                row[3]
                ];
                allData12.push(reorderedRow);
            });
           

function getTeamLeague12(team) {
          for (const [league, teams] of Object.entries(leagues)) {
              if (teams.includes(team)) {
                  return league;
              }
          }
          return "Unknown League";
      }

      const outputLines = [];
      allData12.forEach(row => {
          if (row.length >= 3) {
              const team = row[2];
              const league = getTeamLeague12(team);
              row[12] = league; // Replace the third element with the league information
              outputLines.push(row.join(",")); // Join the modified parts back into a line
          } else {
              // Handle rows that don't have at least 3 elements as needed
              outputLines.push(row.join(","));
          }
      });
        });
    
        // Extract values from columns 4, 5, 6, 7, 8, 9, and 10
        const columnsToConvert = [3, 4, 5, 6, 7, 8, 9];
        const columnValues = columnsToConvert.map(col => allData12.map(row => parseFloat(row[col])));
    
        // Calculate percentiles
        const percentiles = columnValues.map(values => {
            const sorted = [...values].sort((a, b) => a - b);
            return values.map(value => {
                const rank = sorted.indexOf(value) + 1;
                return (rank / sorted.length);
            });
        });
    
        // Replace original values with percentiles
        allData12.forEach((row, rowIndex) => {
            columnsToConvert.forEach((col, colIndex) => {
                row[col] = percentiles[colIndex][rowIndex].toFixed(3);
            });
        });
    }

  

    
    Promise.all(fetchPromises11)
        .then(responses11 => {
            processAndStoreData11(responses11);
    
        
            // Fetch and process the remaining files
            Promise.all(fetchPromises12)
                .then(responses12 => {
                    processAndStoreData12(responses12);
    

                    // Concatenate intermediate data with new data
                    const finalData = allData11.concat(allData12);
    
                    // Reset and assign new unique IDs
                    finalData.forEach((row, index) => {
                        row[0] = `${index + 1}`;
                    });
                    
                    finalData.forEach(row => {
                        allDataAsString6 += row.join(',') + '\n';
                    });
    

                    let csvData6 = allDataAsString6.split('\\n').join('\n');
let rows6 = csvData6.split('\n');
rows6.pop();
csvData6 = rows6.join('\n');


let selectedLeague = "All"; // Declare the selectedLeague variable outside the event listener

document.getElementById('league').addEventListener('change', function () {
  selectedLeague = this.value;
});
    // Store data for each dataset in separate arrays
    const dataArray1 = csvData1.split('\n').map(line => line.split(','));
    const dataArray2 = csvData2.split('\n').map(line => line.split(','));
    const dataArray3 = csvData3.split('\n').map(line => line.split(','));
    const dataArray4 = csvData4.split('\n').map(line => line.split(','));
    const dataArray5 = csvData5.split('\n').map(line => line.split(','));
    const dataArray6 = csvData6.split('\n').map(line => line.split(','));





 const metricNames1 = [
      'Def actions',
      'Aerials',
      'Exit line',
      'Passes',
      'Long pass%',
      'Short pass%',
      'PSxG - GA'
    ];

    // Metric names for CB
    const metricNames2 = [
      'Passes',
      'Forward pass%',
      'Prog passes',
      'Def actions',
      'Def duel%',
      'Aerial%',
      'Prog carries'
    ];

    // Metric names for FB
    const metricNames3 = [
      'Cross%',
      'xA',
      'Prog passes',
      'Def actions',
      'Def duel%',
      'Aerial%',
      'Prog carries'
    ];

    // Metric names for CM
    const metricNames4 = [
      'Duel%',
      'Def actions',
      'Prog carries',
      'Forward passes',
      'Forward pass%',
      'Key passes',
      'Prog passes'
    ];

    // Metric names for FW
    const metricNames5 = [
      'Prog carries',
      'Dribbles',
      'NPG',
      'xG+xA',
      'Assists',
      'Key passes',
      'Off actions'
    ];

    // Metric names for ST
    const metricNames6 = [
      'Pass received',
      'Aerial%',
      'NPG',
      'xG',
      'Pass to pen',
      'xA',
      'Off actions'
    ];


    // Function to update metric labels based on the selected dataset
  function updateMetricLabels(dataset) {
    if (!translationsLoaded || !translations || !translations.metrics) {
        console.log('Translations not loaded yet, waiting...');
        return;
    }

    let metricType;
    switch (dataset) {
        case 'dataset2':
            metricType = 'cb';
            break;
        case 'dataset3':
            metricType = 'fb';
            break;
        case 'dataset4':
            metricType = 'cm';
            break;
        case 'dataset5':
            metricType = 'fw';
            break;
        case 'dataset6':
            metricType = 'st';
            break;
        default:
            metricType = 'gk';
    }

    // Get all metric labels
    const labels = document.querySelectorAll('label');
    const metricKeys = Object.keys(translations.metrics[metricType]);
    
    // Update labels with translations
    labels.forEach((label, index) => {
        if (index < metricKeys.length) {
            const translationKey = metricKeys[index];
            const translation = translations.metrics[metricType][translationKey];
            if (translation) {
                label.textContent = translation;
            }
        }
    });
  }


  function reverseSearch(percentiles, dataArray, selectedLeague) {
  return dataArray.filter(data => {
    for (let i = 3; i <= 9; i++) {
      const metricValue = parseFloat(data[i]) * 100;
      if (metricValue < percentiles[i - 3][0]) {
        return false;
      }
    }

    const age = parseInt(data[11]);
    if (age < percentiles[7][0] || age > percentiles[7][1]) {
      return false;
    }

    const minutesPlayed = parseInt(data[10]);
    if (minutesPlayed < percentiles[8][0] || (percentiles[8][1] && minutesPlayed > percentiles[8][1])) {
      return false;
    }

    if (selectedLeague !== "All") {
  if (selectedLeague === "Top 7 Leagues") {
    const topSevenLeagues = [
      "Premier League",
      "La Liga",
      "Bundesliga",
      "Serie A",
      "Ligue 1",
      "Eredivisie",
      "Liga Portugal"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!topSevenLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "Top 5 Leagues") {
    const topFiveLeagues = [
      "Premier League",
      "La Liga",
      "Bundesliga",
      "Serie A",
      "Ligue 1"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!topFiveLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "Non Top 7 Leagues") {
    const dataMBProLeagues = [
      "Scotland Premiership",
      "Belgium Pro League",
      "Swiss Super League",
      "Ukraine",
      "Poland",
      "Greece",
      "Israel",
      "Russia",
      "Colombia",
      "Chile",
      "Paraguay",
      "Ecuador",
      "Austrian Bundesliga",
      "SÃ¼per Lig",
      "Saudi Pro League",
      "Brazil Serie A",
      "Argentina Primera",
      "Uruguay Primera",
      "LigaMX",
      "MLS",
      "K League 1",
      "J1 League",
      "Norway Eliteserien",
      "Denmark Superliga",
      "Sweden Allsvenskan",
      "Czech Fortuna Liga",
      "Serbia SuperLiga",
      "Croatia HNL",
      "Championship",
      "Segunda Division",
      "Bundesliga 2",
      "Serie B",
      "Ligue 2",
      "Unknown League"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!dataMBProLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "South America") {
    const southAmericaLeagues = [
      "Brazil Serie A",
      "Argentina Primera",
      "Uruguay Primera",
      "Colombia",
      "Chile",
      "Paraguay",
      "Ecuador",
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!southAmericaLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "Scandinavia") {
    const scandinaviaLeagues = [
      "Norway Eliteserien",
      "Denmark Superliga",
      "Sweden Allsvenskan"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!scandinaviaLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "Balkans") {
    const balkansLeagues = [
      "Czech Fortuna Liga",
      "Serbia SuperLiga",
      "Croatia HNL",
      "Russia",
      "Ukraine",
      "Poland"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!balkansLeagues.includes(playerLeague)) {
      return false;
    }
  } else if (selectedLeague === "Top 5 Leagues - 2nd Div.") {
    const secondDivLeagues = [
      "Championship",
      "Segunda Division",
      "Bundesliga 2",
      "Serie B",
      "Ligue 2"
    ];
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (!secondDivLeagues.includes(playerLeague)) {
      return false;
    }
  } else {
    const playerLeague = data[12]; // Assuming the league is in the 12th column (index 11)
    if (playerLeague !== selectedLeague) {
      return false;
    }
  }
}

return true;
});
}



  document.getElementById('datasetSelector').addEventListener('change', function () {
    // Check if translations are loaded
    if (!translationsLoaded || !translations || !translations.metrics) {
        console.log('Translations not loaded yet, waiting...');
        return;
    }

    const selectedDataset = document.getElementById('datasetSelector').value;

    // Call the function with the selected dataset to update the metric labels
    switch (selectedDataset) {
      case 'dataset2':
        updateMetricLabels('dataset2');
        break;
      case 'dataset3':
        updateMetricLabels('dataset3');
        break;
      case 'dataset4':
        updateMetricLabels('dataset4');
        break;
      case 'dataset5':
        updateMetricLabels('dataset5');
        break;
      case 'dataset6':
        updateMetricLabels('dataset6');
        break;
      default:
        updateMetricLabels('dataset1');
        break;
    }

    // Clear the search inputs and results when the dataset selector changes
    clearSearchInputs();
});

    // Initialize the metric labels based on the default dataset
    updateMetricLabels('dataset1');



    function clearSearchInputs() {
      // Clear all input fields
      const inputs = document.querySelectorAll('input[type="number"]');
      inputs.forEach(input => (input.value = ''));

      // Clear the results container
      const resultsContainer = document.getElementById('resultsContainer');
      resultsContainer.innerHTML = '';
    }

    document.getElementById('searchForm').addEventListener('submit', function (event) {
      event.preventDefault();

      // Check if translations are loaded
      if (!translations || !translations.metrics) {
          console.log('Waiting for translations to load...');
          return;
      }

      // Get the selected dataset and league
      const selectedDataset = document.getElementById('datasetSelector').value;
      selectedLeague = document.getElementById('league').value;

      // Get the user-entered percentile values from the form
      const defensiveActionsLow = parseInt(document.getElementById('defensiveActionsLow').value);
      const aerialsContestedLow = parseInt(document.getElementById('aerialsContestedLow').value);
      const exitLineLow = parseInt(document.getElementById('exitLineLow').value);
      const passesLow = parseInt(document.getElementById('passesLow').value);
      const longPassPercentageLow = parseInt(document.getElementById('longPassPercentageLow').value);
      const shortPassPercentageLow = parseInt(document.getElementById('shortPassPercentageLow').value);
      const psxgLow = parseInt(document.getElementById('psxgLow').value);
      const ageLow = parseInt(document.getElementById('ageLow').value);
      const ageHigh = parseInt(document.getElementById('ageHigh').value);
      const minutesPlayedLow = parseInt(document.getElementById('minutesPlayedLow').value);
      const minutesPlayedHigh = parseInt(document.getElementById('minutesPlayedHigh').value);

      // Determine the dataArray based on the selected dataset
      let dataArray;
      switch (selectedDataset) {
        case 'dataset2':
          dataArray = dataArray2;
          break;
        case 'dataset3':
          dataArray = dataArray3;
          break;
        case 'dataset4':
          dataArray = dataArray4;
          break;
        case 'dataset5':
          dataArray = dataArray5;
          break;
        case 'dataset6':
          dataArray = dataArray6;
          break;
        default:
          dataArray = dataArray1;
      }

      // Filter the dataArray based on user-entered percentiles
      const restrictedPlayers = reverseSearch(
    [
      [defensiveActionsLow],
      [aerialsContestedLow],
      [exitLineLow],
      [passesLow],
      [longPassPercentageLow],
      [shortPassPercentageLow],
      [psxgLow],
      [ageLow, ageHigh],
      [minutesPlayedLow, minutesPlayedHigh]
    ],
    dataArray, // Pass the dataArray as a parameter
    selectedLeague // Pass the selected league as a parameter
  );
  const resultsContainer = document.getElementById('resultsContainer');
  resultsContainer.innerHTML = '';

  if (restrictedPlayers.length === 0) {
    const noResultsMessage = document.createElement('p');
    noResultsMessage.textContent = 'No players found';
    noResultsMessage.classList.add('no-results-message'); // Add a class to the element
    resultsContainer.appendChild(noResultsMessage);
  } else {
    // Create the table element
    const table = document.createElement('table');

    // Create the table header
    const tableHeader = createTableHeader();
    table.appendChild(tableHeader);

    // Create the table body
    const tableBody = document.createElement('tbody');

    // Add the player data rows to the table body
    restrictedPlayers.forEach(playerData => {
      const playerRow = document.createElement('tr');
      tableBody.appendChild(playerRow);

      // Add the player name and other info in the first column
      const playerNameCell = document.createElement('td');
      const playerName = playerData[1];
      const playerData2 = playerData[2];
      const playerData11 = playerData[11];
      const playerData10 = playerData[10];


      // Create a formatted HTML string
      const formattedText = `<span>${playerName}</span><br><span class="player-info">${playerData11}, ${playerData2}, ${playerData10} min</span>`;

      // Set the formatted HTML as the content of playerNameCell
      playerNameCell.innerHTML = formattedText;
      playerRow.appendChild(playerNameCell);

      // Add the player metric values in the subsequent columns
   for (let i = 3; i <= 9; i++) {
    const metricValueCell = document.createElement('td');
    const numericValue = (parseFloat(playerData[i]) * 100).toFixed(2);

    // Apply the color inline style based on the value range
    metricValueCell.textContent = numericValue;
    if (numericValue >= 75 && numericValue <= 100) {
      metricValueCell.style.color = 'green';
    } else if (numericValue >= 0 && numericValue <= 25) {
      metricValueCell.style.color = 'red';
    }
    
    playerRow.appendChild(metricValueCell);
  }
    });

    // Append the table body to the table
    table.appendChild(tableBody);

    // Append the table to the wrapper container
    const tableWrapper = document.getElementById('tableWrapper');
    tableWrapper.innerHTML = ''; // Clear any previous content
    tableWrapper.appendChild(table);
  }

    });

let sortColumnIndex = -1;
let ascending = true;

function createTableHeader() {
    // Check if translations are loaded
    if (!translationsLoaded || !translations || !translations.metrics) {
        console.log('Translations not loaded yet, waiting...');
        return null;
    }

    const tableHeader = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const selectedDataset = document.getElementById('datasetSelector').value;
    let metricType;
    
    switch (selectedDataset) {
        case 'dataset2':
            metricType = 'cb';
            break;
        case 'dataset3':
            metricType = 'fb';
            break;
        case 'dataset4':
            metricType = 'cm';
            break;
        case 'dataset5':
            metricType = 'fw';
            break;
        case 'dataset6':
            metricType = 'st';
            break;
        default:
            metricType = 'gk';
    }

    const emptyHeaderCell = document.createElement('th');
    emptyHeaderCell.textContent = '';
    headerRow.appendChild(emptyHeaderCell);

    const metricKeys = Object.keys(translations.metrics[metricType]);
    for (let i = 0; i < metricKeys.length; i++) {
        const headerCell = document.createElement('th');
        headerCell.textContent = translations.metrics[metricType][metricKeys[i]];
        headerCell.style.cursor = 'pointer';
        headerCell.setAttribute('data-i18n', `metrics.${metricType}.${metricKeys[i]}`);

        // Add click event listener to the header cell for sorting
        headerCell.addEventListener('click', () => {
            sortColumn(i);
        });

        headerRow.appendChild(headerCell);
    }

    tableHeader.appendChild(headerRow);
    return tableHeader;
}


function sortColumn(columnIndex) {
  // Check if it's a different column or the same column that needs to be reversed
  if (sortColumnIndex === columnIndex) {
    ascending = !ascending;
  } else {
    ascending = false;
    sortColumnIndex = columnIndex;
  }

  // Get the table body rows
  const tableBody = document.querySelector('tbody');
  const rows = Array.from(tableBody.querySelectorAll('tr'));

  // Sort the rows based on the selected column
  rows.sort((row1, row2) => {
    const value1 = parseFloat(row1.children[columnIndex + 1].textContent);
    const value2 = parseFloat(row2.children[columnIndex + 1].textContent);

    if (ascending) {
      return value1 - value2;
    } else {
      return value2 - value1;
    }
  });

  // Clear the current table body content
  tableBody.innerHTML = '';

  // Append the sorted rows to the table body
  rows.forEach(row => {
    tableBody.appendChild(row);
  });
}


  document.getElementById('datasetSelector').addEventListener('change', function () {
    const selectedDataset = document.getElementById('datasetSelector').value;

    // Call the function with the selected dataset to update the metric labels
    switch (selectedDataset) {
      case 'dataset2':
        updateMetricLabels('dataset2');
        break;
      case 'dataset3':
        updateMetricLabels('dataset3');
        break;
      case 'dataset4':
        updateMetricLabels('dataset4');
        break;
      case 'dataset5':
        updateMetricLabels('dataset5');
        break;
      case 'dataset6':
        updateMetricLabels('dataset6');
        break;
      default:
        updateMetricLabels('dataset1');
        break;
    }

    // Clear the search inputs and results when the dataset selector changes
    clearSearchInputs();
});

function loadTranslations(language) {
    console.log('Loading translations for language:', language);
    return fetch(`locales/${language}.json`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Translations loaded successfully:', data);
            translations = data;
            translationsLoaded = true;
            
            // Update all elements with translations
            updateAllTranslations(language);
            
            // Initialize the table header after translations are loaded
            const table = document.querySelector('table');
            if (table) {
                console.log('Found table, updating header');
                const oldHeader = table.querySelector('thead');
                if (oldHeader) {
                    console.log('Removing old header');
                    oldHeader.remove();
                }
                const newHeader = createTableHeader();
                if (newHeader) {
                    console.log('Adding new header');
                    table.insertBefore(newHeader, table.firstChild);
                } else {
                    console.log('Failed to create new header');
                }
            } else {
                console.log('No table found');
            }
            
            // Initialize the metric labels
            console.log('Updating metric labels');
            updateMetricLabels('dataset1');
        })
        .catch(error => {
            console.error('Error loading translations:', error);
            // Load English as fallback
            if (language !== 'en') {
                console.log('Falling back to English translations');
                return loadTranslations('en');
            }
        });
}

function updateAllTranslations(language) {
    if (!translations) {
        console.log('No translations available');
        return;
    }
    
    console.log('Updating translations for language:', language);
    
    // Update text content for elements with data-i18n attribute
    const elements = document.querySelectorAll('[data-i18n]');
    console.log('Found elements with data-i18n:', elements.length);
    
    elements.forEach(element => {
        const keys = element.getAttribute('data-i18n').split('.');
        let value = translations;
        for (const key of keys) {
            value = value?.[key];
        }
        if (value) {
            console.log('Updating element:', element, 'with value:', value);
            element.textContent = value;
        } else {
            console.log('No translation found for:', keys.join('.'));
        }
    });

    // Update placeholders
    const placeholderElements = document.querySelectorAll('[data-i18n-placeholder]');
    console.log('Found elements with data-i18n-placeholder:', placeholderElements.length);
    
    placeholderElements.forEach(element => {
        const keys = element.getAttribute('data-i18n-placeholder').split('.');
        let value = translations;
        for (const key of keys) {
            value = value?.[key];
        }
        if (value) {
            console.log('Updating placeholder:', element, 'with value:', value);
            element.placeholder = value;
        } else {
            console.log('No translation found for placeholder:', keys.join('.'));
        }
    });

    // Update meta tags
    if (translations.meta) {
        console.log('Updating meta tags');
        document.title = translations.meta.title;
        document.querySelector('meta[name="description"]')?.setAttribute('content', translations.meta.description);
        document.querySelector('meta[name="language"]')?.setAttribute('content', language);
    } else {
        console.log('No meta translations found');
    }
}

// Initialize translations when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    const preferredLanguage = getPreferredLanguage();
    console.log('Initializing with language:', preferredLanguage);
    loadTranslations(preferredLanguage);
});

})}) })}) })}) })}) })}) })}) 
</script></div>

<script>

    // Function to toggle dark mode
    function toggleDarkMode() {
      const body = document.querySelector("body");
      body.classList.toggle("dark-mode");

      // Store the user's preference in local storage
      const isDarkMode = body.classList.contains("dark-mode");
      localStorage.setItem("darkMode", isDarkMode);
    }

    // Check if user has a stored preference for dark mode
    const storedDarkMode = localStorage.getItem("darkMode");

    if (storedDarkMode === "true") {
      const body = document.querySelector("body");
      body.classList.add("dark-mode");
    }

  </script>


<a href="https://datamb.football/prosearch/" target="_self" rel="noopener noreferrer">
  <button class="button-6" role="button" data-i18n="switch.button">Switch to 2023/24</button></a>
  
<div class="dark-mode-toggle" onclick="toggleDarkMode()">
    <span class="toggle-icon"></span>
  </div>

  <script>
    // Global variables for translations
    let translations = {};
    let translationsLoaded = false;

    // Translation functionality
    function setLanguage(language) {
        localStorage.setItem('preferredLanguage', language);
        const url = new URL(window.location.href);
        if (language === 'en') {
            url.searchParams.delete('lang');
        } else {
            url.searchParams.set('lang', language);
        }
        window.history.pushState({}, '', url);
        loadTranslations(language);
    }
    
    function getPreferredLanguage() {
        const urlParams = new URLSearchParams(window.location.search);
        const langParam = urlParams.get('lang');
        if (langParam) {
            return langParam;
        }
        return localStorage.getItem('preferredLanguage') || getBrowserLanguage() || 'en';
    }
    
    
    function getBrowserLanguage() {
      return navigator.language.slice(0, 2);
    }
    
    function loadTranslations(language) {
        return fetch(`locales/${language}.json`)
            .then(response => response.json())
            .then(data => {
                translations = data;
                translationsLoaded = true;
                
                // Update all elements with translations
                updateAllTranslations(language);
                
                // Initialize the table header after translations are loaded
                const table = document.querySelector('table');
                if (table) {
                    const oldHeader = table.querySelector('thead');
                    if (oldHeader) oldHeader.remove();
                    const newHeader = createTableHeader();
                    if (newHeader) {
                        table.insertBefore(newHeader, table.firstChild);
                    }
                }
                
                // Initialize the metric labels
                updateMetricLabels('dataset1');
            })
            .catch(error => {
                console.error('Error loading translations:', error);
                // Load English as fallback
                if (language !== 'en') {
                    return loadTranslations('en');
                }
            });
    }

    function updateAllTranslations(language) {
        if (!translations) return;
        
        // Update text content for elements with data-i18n attribute
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const keys = element.getAttribute('data-i18n').split('.');
            let value = translations;
            for (const key of keys) {
                value = value?.[key];
            }
            if (value) {
                element.textContent = value;
            }
        });

        // Update placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
            const keys = element.getAttribute('data-i18n-placeholder').split('.');
            let value = translations;
            for (const key of keys) {
                value = value?.[key];
            }
            if (value) {
                element.placeholder = value;
            }
        });

        // Update meta tags
        if (translations.meta) {
            document.title = translations.meta.title;
            document.querySelector('meta[name="description"]')?.setAttribute('content', translations.meta.description);
            document.querySelector('meta[name="language"]')?.setAttribute('content', language);
        }
    }

    // Initialize translations
    const preferredLanguage = getPreferredLanguage();
    loadTranslations(preferredLanguage);
    
    </script>
</body>
</html>
